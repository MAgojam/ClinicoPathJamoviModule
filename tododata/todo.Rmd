---
title: "ToDo"
---

Remotes:



    easystats/correlation,
    easystats/report



# Future Works:

## ndphillips/FFTrees


Remotes:
    ndphillips/FFTrees,
    easystats/report,
    spgarbet/tangram,
    cran/rmngb,
    mixOmicsTeam/mixOmics








```
            # gtsummary

            # myvars <- jmvcore::constructFormula(terms = self$options$vars)
            # myvars <- jmvcore::decomposeFormula(formula = myvars)
            # myvars <- unlist(myvars)
            # mytableone2 <- self$data %>%
            #     dplyr::select(myvars)
            # mytableone2 <- gtsummary::tbl_summary(mytableone2)
            # self$results$text2$setContent(mytableone2)
```


    # - name: outcomeLevel
    #   title: |
    #       Select Event (Death, Recurrence)
    #   type: Level
    #   variable: (outcome)







---

,
arsenal,

rlang,
knitr,
remotes,
kableExtra,

caret,
irr
Remotes:


easystats/bayestestR,
easystats/performance,
easystats/parameters,
easystats/report
Suggests:
    effectsize,
emmeans,
rmarkdown,
igraph,
iterators,
rms,
commonmark,
sass



# select theme

            originaltheme <- self$options$originaltheme

            if (!originaltheme) {
                plot <- plot + ggtheme
            }


            themex <- self$options$themex


            # , ggtheme = ggtheme


            # plot <- plot + eval(parse(text=self$options$themex))



            if (themex == "jamovi") {
               plot <- plot + ggtheme
            } else if (themex == "original") {
               plot <- plot
            } else if (themex == "ipsum") {
               plot <- plot + hrbrthemes::theme_ipsum()
            } else if (themex == "grey") {
                plot <- plot + ggplot2::theme_grey()
            } else if (themex == "gray") {
                plot <- plot + ggplot2::theme_gray()
            } else if (themex == "bw") {
                plot <- plot + ggplot2::theme_bw()
            } else if (themex == "linedraw") {
                plot <- plot + ggplot2::theme_linedraw()
            } else if (themex == "light") {
             plot <- plot + ggplot2::theme_light()
            } else if (themex == "dark") {
             plot <- plot + ggplot2::theme_dark()
            } else if (themex == "minimal") {
             plot <- plot + ggplot2::theme_minimal()
            } else if (themex == "classic") {
             plot <- plot + ggplot2::theme_classic()
            } else if (themex == "void") {
             plot <- plot + ggplot2::theme_void()
            } else if (themex == "test") {
             plot <- plot + ggplot2::theme_test()
            }





```
# #
# #
# #     if (is.null(self$options$dep) || is.null(self$options$group))
# #         return()
# #
# #     mydata <- self$data
# #
# #     mydep <- self$data[[self$options$dep]]
# #
# #     mygroup <- self$data[[self$options$group]]
# #
# #
# #     # klass <- print(
# #     #     list(
# #     #         "mydep" = c(typeof(mydep), class(mydep)),
# #     #         "mygroup" = c(typeof(mygroup), class(mygroup))
# #     #         )
# #     #     )
# #
# #
# #     # self$results$text1$setContent(klass)
# #
# #
# #     # plotData <- data.frame(gr = mygroup,
# #     #                        dp = mydep)
# #     # plotData <- jmvcore::naOmit(plotData)
# #     # mydata_changes <- plotData %>%
# #     #     dplyr::group_by(gr, dp) %>%
# #     #     dplyr::tally(x = .)
# #     #
# #     # self$results$text2$setContent(mydata_changes)
# #     #
# #     # plotData <- data.frame(gr = mygroup,
# #     #                        dp = mydep)
# #     #
# #     # plotData <- jmvcore::naOmit(plotData)
# #     #
# #     #
# #     # mydata_changes <- plotData %>%
# #     #     dplyr::group_by(gr, dp) %>%
# #     #     dplyr::tally(x = .)
# #     #
# #     #
# #     # deneme <- ggalluvial::is_alluvia_form(
# #     #     as.data.frame(mydata_changes),
# #     #     axes = 1:2, silent = TRUE)
# #
# #     # nodes = data.frame("name" =
# #     #                        c(self$options$group,
# #     #                          self$options$dep))
# #     #
# #     # links <- mydata_changes
# #     #
# #     # names(links) = c("source", "target", "value")
# #     #
# #     # deneme <- networkD3::sankeyNetwork(Links = links, Nodes = nodes,
# #     #                                  Source = "source", Target = "target",
# #     #                                  Value = "value", NodeID = "name",
# #     #                                  fontSize= 12, nodeWidth = 30)
# #
# #
# #
# #     # self$results$text3$setContent(deneme)
# #
# #
# #
# #
# #     # Prepare Data for Plot ----
# #
# #     direction <- self$options$direction
# #
# #     mydata <- self$data
# #
# #     mydep <- self$data[[self$options$dep]]
# #
# #     mygroup <- self$data[[self$options$group]]
# #
# #     contin <- c("integer", "numeric", "double")
# #     categ <- c("factor")
# #
# # # independent, factor, continuous ----
# # # ggbetweenstats 	violin plots 	for comparisons between groups/conditions
# #     if (direction == "independent" && class(mygroup) == "factor" && class(mydep) %in% contin) {
# #             plotData <- data.frame(gr = mygroup,
# #                                    dp = jmvcore::toNumeric(mydep))
# #
# #
# #
# #             todo <- glue::glue(
# #                 "This Module is still under development
# #         🔬🔬🔬🔬 UNDER CONSTRUCTION 🛠⛔️⚠️🔩
# #         -
# #         -  "
# #             )
# #
# #
# #
# #         }
# #
# #
# # # independent, continuous, continuous ----
# # # ggscatterstats 	scatterplots 	for correlations between two variables
# #
# #     if (direction == "independent" && class(mygroup) %in% contin && class(mydep) %in% contin) {
# #             plotData <- data.frame(gr = jmvcore::toNumeric(mygroup),
# #                                    dp = jmvcore::toNumeric(mydep))
# #
# #
# #
# #
# #             todo <- glue::glue(
# #                 "This Module is still under development
# #         🔬🔬🔬🔬 UNDER CONSTRUCTION 🛠⛔️⚠️🔩
# #         -
# #         -  "
# #             )
# #     }
# #
# #
# # # independent, factor, factor ----
# # # ggbarstats 	bar charts 	for categorical data
# #     if (direction == "independent" && class(mygroup) == "factor" && class(mydep) == "factor") {
# #
# #             plotData <- data.frame(gr = mygroup,
# #                                    dp = mydep)
# #
# #
# #
# #             todo <- glue::glue(
# #                 "This Module is still under development
# #         🔬🔬🔬🔬 UNDER CONSTRUCTION 🛠⛔️⚠️🔩
# #         -
# #         -  "
# #             )
# #
# #
# #         }
# #
# #     # independent, continuous, factor ----
# #
# #     if (direction == "independent" && class(mygroup) %in% contin && class(mydep) == "factor") {
# #         todo <- glue::glue(
# #             "This Module is still under development
# #         🔬🔬🔬🔬 UNDER CONSTRUCTION 🛠⛔️⚠️🔩
# #         - Please switch the values: factor variable should be on x-axis and continuous variable should be on y-axis
# #         -  "
# #         )
# #
# #         stop("Please switch the values: factor variable should be on x-axis and continuous variable should be on y-axis")
# #         }
# #
# #
# #
# #     # repeated, factor, continuous ----
# #     # ggwithinstats 	violin plots 	for comparisons within groups/conditions
# #
# #
# #
# #     if (direction == "repeated" && class(mygroup) == "factor" && class(mydep) %in% contin) {
# #             plotData <- data.frame(gr = mygroup,
# #                                    dp = jmvcore::toNumeric(mydep))
# #
# #
# #
# #             todo <- glue::glue(
# #                 "This Module is still under development
# #         🔬🔬🔬🔬 UNDER CONSTRUCTION 🛠⛔️⚠️🔩
# #         -
# #         -  "
# #             )
# #
# #
# #             }
# #
# #
# #     # repeated, continuous, continuous ----
# #     # rmcorr::rmcorr()
# #
# #
# #     if (direction == "repeated" && class(mygroup) %in% contin && class(mydep) %in% contin) {
# #         todo <- glue::glue(
# #             "This Module is still under development
# #         🔬🔬🔬🔬 UNDER CONSTRUCTION 🛠⛔️⚠️🔩
# #         - Currently this module does not support repeated measures correlation.
# #         -  "
# #         )
# #
# #
# #         stop("Currently this module does not support repeated measures correlation.")
# #
# #     }
# #
# #
# #     # repeated, factor, factor ----
# #     # http://corybrunson.github.io/ggalluvial/
# #
# #     if (direction == "repeated" && class(mygroup) == "factor" && class(mydep) == "factor") {
# #             plotData <- data.frame(gr = mygroup,
# #                                    dp = mydep)
# #
# #
# #
# #             todo <- glue::glue(
# #                 "This Module is still under development
# #         🔬🔬🔬🔬 UNDER CONSTRUCTION 🛠⛔️⚠️🔩
# #         -
# #         -  "
# #             )
# #         }
# #
# #     # repeated, continuous, factor ----
# #
# #     if (direction == "repeated" && class(mygroup) %in% contin && class(mydep) == "factor") {
# #
# #         todo <- glue::glue(
# #             "This Module is still under development
# #         🔬🔬🔬🔬 UNDER CONSTRUCTION 🛠⛔️⚠️🔩
# #         - Please switch the values: factor variable should be on x-axis and continuous variable should be on y-axis
# #         -  "
# #         )
# #
# #
# #         stop("Please switch the values: factor variable should be on x-axis and continuous variable should be on y-axis")
# #
# #
# #     }
# 
# 
# 
# 
# 
# # Results ----
# 
# 
# 
# # Send Data to Plot ----
# 
# # plotData <- jmvcore::naOmit(plotData)
# # image <- self$results$plot
# # image$setState(plotData)
# 
# 
# # }
# 
# 
# # ,
# #
# # .plot = function(image, ...) {  # <-- the plot function ----
# #
# #
# #     if (is.null(self$options$dep) || is.null(self$options$group))
# #         return()
# #
# #
# #     plotData <- image$state
# #
# #     direction <- self$options$direction
# #
# #     mydata <- self$data
# #
# #     mydep <- self$data[[self$options$dep]]
# #
# #     mygroup <- self$data[[self$options$group]]
# #
# #     contin <- c("integer", "numeric", "double")
# #     categ <- c("factor")
# #
# #     # independent, factor, continuous ----
# #     # ggbetweenstats 	violin plots 	for comparisons between groups/conditions
# #
# #     if (direction == "independent" && class(mygroup) == "factor" && class(mydep) %in% contin) {
# #
# #             plot <- ggstatsplot::ggbetweenstats(
# #                 data = plotData,
# #                 x = gr,
# #                 y = dp
# #             )
# #         }
# #
# #     # independent, continuous, continuous ----
# #     # ggscatterstats 	scatterplots 	for correlations between two variables
# #
# #
# #         if (direction == "independent" && class(mygroup) %in% contin && class(mydep) %in% contin) {
# #
# #             plot <- ggstatsplot::ggscatterstats(
# #                 data = plotData,
# #                 x = gr,
# #                 y = dp
# #             )
# #
# #         }
# #
# #     # independent, factor, factor ----
# #     # ggbarstats 	bar charts 	for categorical data
# #
# #
# #     if (direction == "independent" && class(mygroup) == "factor" && class(mydep) == "factor") {
# #
# #
# #
# #             plot <- ggstatsplot::ggbarstats(
# #                                     data = plotData,
# #                                     main = gr,
# #                                     condition = dp
# #                                 )
# #         }
# #
# #     # repeated, factor, continuous ----
# #     # ggwithinstats 	violin plots 	for comparisons within groups/conditions
# #
# #
# # if (direction == "repeated" && class(mygroup) == "factor" && class(mydep) %in% contin) {
# #
# #
# #             plot <- ggstatsplot::ggwithinstats(
# #                 data = plotData,
# #                 x = gr,
# #                 y = dp
# #             )
# #
# #         }
# #
# #     # repeated, continuous, continuous ----
# #     # rmcorr::rmcorr()
# #
# #             # my.rmc <- rmcorr::rmcorr(participant = Subject,
# #             #                          measure1 = PacO2,
# #             #                          measure2 = pH,
# #             #                          dataset = rmcorr::bland1995)
# #             #
# #             # plot(my.rmc, overall = TRUE)
# #             #
# #             # ggplot2::ggplot(rmcorr::bland1995,
# #             #                 ggplot2::aes(x = PacO2,
# #             #                              y = pH,
# #             #                              group = factor(Subject),
# #             #                              color = factor(Subject)
# #             #                 )
# #             # ) +
# #             #     ggplot2::geom_point(ggplot2::aes(colour = factor(Subject))) +
# #             #     ggplot2::geom_line(ggplot2::aes(y = my.rmc$model$fitted.values), linetype = 1)
# #
# #
# #
# #     # repeated, factor, factor ----
# #     # http://corybrunson.github.io/ggalluvial/
# #     # networkD3
# #
# #
# #     if (direction == "repeated" && class(mygroup) == "factor" && class(mydep) == "factor") {
# #
# #
# #             mydata_changes <- plotData %>%
# #                 dplyr::group_by(gr, dp) %>%
# #                 dplyr::tally(x = .)
# #
# #
# #             # head(as.data.frame(UCBAdmissions), n = 12)
# #
# #             # ggalluvial::is_alluvia_form(
# #             #     as.data.frame(UCBAdmissions),
# #             #     axes = 1:3, silent = TRUE)
# #
# #
# #
# #             # plot <- ggplot(as.data.frame(UCBAdmissions),
# #             #        aes(y = Freq, axis1 = Gender, axis2 = Dept)) +
# #             #     geom_alluvium(aes(fill = Admit), width = 1/12) +
# #             #     geom_stratum(width = 1/12, fill = "black", color = "grey") +
# #             #     geom_label(stat = "stratum", infer.label = TRUE) +
# #             #     scale_x_discrete(limits = c("Gender", "Dept"), expand = c(.05, .05)) +
# #             #     scale_fill_brewer(type = "qual", palette = "Set1") +
# #             #     ggtitle("UC Berkeley admissions and rejections, by sex and department")
# #
# #
# #
# #
# #
# #             stratum <- ggalluvial::StatStratum
# #
# #             plot <- ggplot2::ggplot(data = mydata_changes,
# #                                     ggplot2::aes(axis1 = gr,
# #                        axis2 = dp,
# #                        y = n)) +
# #                 ggplot2::scale_x_discrete(limits = c(self$options$group, self$options$dep),
# #                                  expand = c(.1, .05)
# #                 ) +
# #                 ggplot2::xlab(self$options$group) +
# #                 ggalluvial::geom_alluvium(ggplot2::aes(fill = gr,
# #                                   colour = gr
# #                 )) +
# #                 ggalluvial::geom_stratum() +
# #                 ggalluvial::stat_stratum(geom = "stratum") +
# #                 ggplot2::geom_label(stat = stratum, infer.label = TRUE) +
# #
# #                 # ggalluvial::geom_stratum(stat = "stratum", label.strata = TRUE) +
# #                 # ggplot2::geom_text(stat = "stratum", infer.label = TRUE) +
# #                 # ggplot2::geom_text(label.strata = TRUE) +
# #                 # ggalluvial::geom_stratum()
# #                 ggplot2::theme_minimal()
# #                 # ggplot2::ggtitle(paste0("Changes in ", self$options$group))
# #             #
# #             #
# #             # nodes = data.frame("name" =
# #             #                        c(self$options$group,
# #             #                          self$options$dep))
# #             #
# #             # links <- mydata_changes
# #             #
# #             # names(links) = c("source", "target", "value")
# #             #
# #             # plot <- networkD3::sankeyNetwork(Links = links, Nodes = nodes,
# #             #               Source = "source", Target = "target",
# #             #               Value = "value", NodeID = "name",
# #             #               fontSize= 12, nodeWidth = 30)
# #
# #             # library(networkD3)
# #             # nodes = data.frame("name" =
# #             #                        c("Node A", # Node 0
# #             #                          "Node B", # Node 1
# #             #                          "Node C", # Node 2
# #             #                          "Node D"))# Node 3
# #             # links = as.data.frame(matrix(c(
# #             #     0, 1, 10, # Each row represents a link. The first number
# #             #     0, 2, 20, # represents the node being conntected from.
# #             #     1, 3, 30, # the second number represents the node connected to.
# #             #     2, 3, 40),# The third number is the value of the node
# #             #     byrow = TRUE, ncol = 3))
# #             # names(links) = c("source", "target", "value")
# #             # sankeyNetwork(Links = links, Nodes = nodes,
# #             #               Source = "source", Target = "target",
# #             #               Value = "value", NodeID = "name",
# #             #               fontSize= 12, nodeWidth = 30)
# #
# #             # plot <- c("Under Construction")
# #
# #             # plot <- list(plot1,
# #             #              plot2)
# #
# #
# #
# #         }
# #
# #
# #
# #     print(plot)
# #     TRUE
# #
# # }
# #
# #         )
# # )
```














---

# Packages

require(devtools)
install_version("ggplot2", version = "0.9.1", repos = "http://cran.us.r-project.org")

packageurl <- "https://cran.r-project.org/src/contrib/Archive/ggstatsplot/ggstatsplot_0.5.0.tar.gz"
install.packages(packageurl, repos=NULL, type="source")




Imports: 
    jmvcore (>= 0.8.5),
    R6,
    dplyr,
    survival,
    survminer,
    finalfit,
    arsenal,
    purrr,
    glue,
    janitor,
    ggplot2,
    forcats,
    ggstatsplot,
    tableone,
    explore,
    tangram,
    irr,
    rlang,
    tidyselect,
    knitr



Remotes:
    easystats/correlation,
    neuropsychology/psycho.R@0.4.0


Suggests:
    rmarkdown,
    remotes,
    devtools,
    lubridate,
    broom, 
    GGally, 
    gridExtra, 
    Hmisc, 
    lme4, 
    magrittr, 
    mice, 
    pillar, 
    pROC, 
    scales, 
    stringr, 
    tibble, 
    tidyr, 
    covr, 
    cmprsk, 
    readr, 
    rstan, 
    survey, 
    testthat, 
    backports, 
    generics, 
    assertthat, 
    pkgconfig, 
    Rcpp, 
    BH, 
    plogr, 
    ellipsis, 
    gtable, 
    progress, 
    RColorBrewer, 
    reshape, 
    digest, 
    lazyeval, 
    viridisLite, 
    withr, 
    Formula, 
    latticeExtra, 
    acepack, 
    data.table, 
    htmlTable, 
    viridis, 
    htmltools, 
    base64enc, 
    minqa, 
    nloptr, 
    RcppEigen, 
    mitml, 
    cli, 
    crayon, 
    fansi, 
    utf8, 
    vctrs, 
    farver, 
    labeling, 
    munsell, 
    lifecycle, 
    stringi, 
    ggpubr, 
    maxstat, 
    survMisc, 
    jsonlite, 
    rex, 
    evaluate, 
    highr, 
    markdown, 
    xfun, 
    hms, 
    clipr, 
    mime, 
    tinytex, 
    StanHeaders, 
    inline, 
    loo, 
    pkgbuild, 
    numDeriv, 
    mitools, 
    pkgload, 
    praise, 
    zeallot, 
    colorspace, 
    prettyunits, 
    checkmate, 
    htmlwidgets, 
    pan, 
    jomo, 
    ordinal, 
    ucminf, 
    ggrepel,
    ggsci, 
    cowplot, 
    ggsignif,
    polynom, 
    exactRankTests,
    mvtnorm, 
    KMsurv, 
    zoo, 
    km.ci,
    xtable,
    curl, 
    openssl, 
    askpass, 
    sys, 
    matrixStats,
    callr, 
    desc,
    rprojroot,
    processx, 
    ps, 
    DBI,
    png, 
    jpeg, 
    boot, 
    grid, 
    snakecase,
    caret,
    iterators,
    timeDate,
    foreach,
    plyr,
    ModelMetrics,
    nlme,
    reshape2,
    recipes,
    BradleyTerry2,
    e1071,
    earth,
    fastICA,
    gam,
    ipred,
    kernlab,
    klaR,
    MASS,
    ellipse,
    mda,
    mgcv,
    mlbench,
    MLmetrics,
    nnet,
    party,
    pls,
    proxy,
    randomForest,
    RANN,
    spls,
    subselect,
    pamr,
    superpc,
    Cubist,
    rpart,
    qgraph,
    nFactors,
    ppcor,
    rstanarm,
    MuMIn,
    blavaan,
    
    
    
    
    



# Develop



```{r library, eval=FALSE, include=FALSE}
# install.packages('jmvtools', repos=c('https://repo.jamovi.org', 'https://cran.r-project.org'))

# jmvtools::check("C://Program Files//jamovi//bin")

# jmvtools::install(home = "C://Program Files//jamovi//bin")
# 
# jmvtools::install(pkg = "C://ClinicoPath", home = "C://Program Files//jamovi//bin")

# devtools::build(path = "C:\\ClinicoPathOutput")

# .libPaths(new = "C:\\ClinicoPathLibrary")

# devtools::build(path = "C:\\ClinicoPathOutput", binary = TRUE, args = c('--preclean'))

Sys.setenv(TZ = "Europe/Istanbul")

library("jmvtools")
```


```{r check, eval=FALSE, include=FALSE}
jmvtools::check()

# rhub::check_on_macos()

rhub::check_for_cran()

# codemetar::write_codemeta()


devtools::check()

```

```{r description, eval=FALSE, include=FALSE}
# From CRAN
# install.packages("attachment")
# From github
# remotes::install_github("ThinkR-open/attachment")

# If you correctly called the package dependencies in the {roxygen2} skeleton, in your functions, in your Rmarkdown vignettes and in your tests, you only need to run attachment::att_to_description()just before devtools::check(). And that’s it, there is nothing else to remember !
# attachment::att_to_description()

```




```{r pkgdown build, include=FALSE}

devtools::document()

codemetar::write_codemeta()

# rmarkdown::render('/Users/serdarbalciold/histopathRprojects/ClinicoPath/README.Rmd',  encoding = 'UTF-8', knit_root_dir = '~/histopathRprojects/ClinicoPath', quiet = TRUE)


pkgdown::build_articles()
# pkgdown::build_favicons()
pkgdown::build_home()
pkgdown::build_news()
pkgdown::build_reference()
# pkgdown::build_reference_index()
# pkgdown::build_tutorials()

pkgdown::build_site()

# devtools::github_release()

```


```{r git force push, include=FALSE}
# gitUpdateCommitPush
CommitMessage <- paste("updated on ", Sys.time(), sep = "")
wd <- getwd()
gitCommand <- paste("cd ", wd, " \n git add . \n git commit --message '", CommitMessage, "' --no-verify \n git push origin master \n", sep = "")
# gitCommand <- paste("cd ", wd, " \n git add . \n git commit --no-verify --message '", CommitMessage, "' \n git push origin master \n", sep = "")
system(command = gitCommand, intern = TRUE)

```



```{r add analysis, eval=FALSE, include=FALSE}

# jmvtools::install()
# 
# jmvtools::create('SuperAwesome')
# 
# jmvtools::addAnalysis(name='ttest', title='Independent Samples T-Test')
# 
# jmvtools::addAnalysis(name='survival', title='survival')
# 
# jmvtools::addAnalysis(name='correlation', title='correlation')
# 
# jmvtools::addAnalysis(name='tableone', title='TableOne')
# 
# jmvtools::addAnalysis(name='crosstable', title='CrossTable')
# 
# 
# jmvtools::addAnalysis(name='writesummary', title='WriteSummary')

# jmvtools::addAnalysis(name='finalfit', title='FinalFit')

# jmvtools::addAnalysis(name='multisurvival', title='FinalFit Multivariate Survival')

# jmvtools::addAnalysis(name='report', title='Report General Features')

# jmvtools::addAnalysis(name='frequencies', title='Frequencies')

# jmvtools::addAnalysis(name='statsplot', title='GGStatsPlot')

# jmvtools::addAnalysis(name='statsplot2', title='GGStatsPlot2')

# jmvtools::addAnalysis(name='statsplotbetween', title='Stats Plot Between')

# jmvtools::addAnalysis(name='competingsurvival', title='Competing Survival')


# jmvtools::addAnalysis(name='scat2', title='scat2')

# jmvtools::addAnalysis(name='decisioncalculator', title='Decision Calculator')

# jmvtools::addAnalysis(name='agreement', title='Interrater Intrarater Reliability')

# jmvtools::addAnalysis(name='cluster', title='Cluster Analysis')

# jmvtools::addAnalysis(name='tree', title='Decision Tree')
# 
# jmvtools::addAnalysis(name='oddsratio', title='Odds Ratio Table and Plot')

# jmvtools::addAnalysis(name='roc', title='ROC')

# jmvtools::addAnalysis(name = "icccoeff", title = "ICC coefficients")

# jmvtools::addAnalysis(name = "gtsummary", title = "Tables via gtsummary")

# jmvtools::addAnalysis(name = "alluvial", title = "Alluvial Diagrams")

# jmvtools::addAnalysis(name = "jjbarstats", title = "Bar")
 
# jmvtools::addAnalysis(name = "jjcoefstats", title = "Dot-and-whisker")
 
# jmvtools::addAnalysis(name = "jjcorrmat", title = "jjcorrmat")

# jmvtools::addAnalysis(name = "jjdotplotstats", title = "jjdotplotstats")

# jmvtools::addAnalysis(name = "jjhistostats", title = "jjhistostats")

# jmvtools::addAnalysis(name = "jjpiestats", title = "jjpiestats")

# jmvtools::addAnalysis(name = "jjscatterstats", title = "jjscatterstats")

# jmvtools::addAnalysis(name = "jjwithinstats", title = "jjwithinstats")

# jmvtools::addAnalysis(name = "jjbarstats2", title = "jjbarstats2")

# jmvtools::addAnalysis(name = "retracted", title = "Find Retracted Papers from DOI")

# jmvtools::addAnalysis(name = "agepyramid", title = "Age Pyramid")

# jmvtools::addAnalysis(name = "timeinterval", title = "Time Interval")

# jmvtools::addAnalysis(name = "decision2", title = "Decision 2 for using init")

# jmvtools::addAnalysis(name = "lollipop", title = "Lollipop Chart")

# jmvtools::addAnalysis(name = "linechart", title = "Line Chart")

# jmvtools::addAnalysis(name = "dendogram", title = "Dendogram")

# jmvtools::addAnalysis(name = "parallelplot", title = "Parallel Plot")

# jmvtools::addAnalysis(name = "ridgeline", title = "Ridgeline Plot")

# jmvtools::addAnalysis(name = "nomogram", title = "Nomogram")

# jmvtools::addAnalysis(name = "benford", title = "Benford Analysis")

# jmvtools::addAnalysis(name = "pairchi2", title = "Pairwise Chi-Square Test")

# jmvtools::addAnalysis(name = "survivalcont", title = "Survival Analysis for Continuous Explanatory")

```






```{r devtools install, eval=FALSE, include=FALSE}
Sys.unsetenv("R_PROFILE_USER")
devtools::check()

devtools::install()
```


```{r jmvtools install, eval=FALSE, include=FALSE}
# jmvtools::check()
jmvtools::install()
```



```{r construct formula}
formula <- jmvcore::constructFormula(terms = c("A", "B", "C"), dep = "D")
```


```{r construct formula 2}
jmvcore::constructFormula(terms = list("A", "B", c("C", "D")), dep = "E")

jmvcore::constructFormula(terms = "A B")


jmvcore::constructFormula(terms = list("A", "B", "C"))

vars <- jmvcore::decomposeFormula(formula = formula) 

unlist(vars)

cformula <- jmvcore::composeTerm(components = formula)

jmvcore::composeTerm("A B")

jmvcore::composeTerm(components = c("A", "B", "C"))

jmvcore::decomposeTerm(term = c("A", "B", "C"))

jmvcore::decomposeTerm(term = formula)

jmvcore::decomposeTerm(term = cformula)



composeTerm <- jmvcore::composeTerm(components = c("A", "B", "C"))

jmvcore::decomposeTerm(term = composeTerm)


```





---


```{r read and write data, eval=FALSE, include=FALSE}
BreastCancer <- readr::read_csv(file = "/Users/serdarbalciold/histopathRprojects/ClinicoPath/data/BreastCancer.csv")

usethis::use_data(BreastCancer)

BreastCancer <- readr::read_csv(file = "/Users/serdarbalciold/histopathRprojects/ClinicoPath/data/BreastCancer.csv")

usethis::use_data(BreastCancer)

colon <- readr::read_csv(file = 
"/Users/serdarbalciold/histopathRprojects/ClinicoPath/data/colon.csv")

usethis::use_data(colon)


melanoma <- readr::read_csv(file = 
"/Users/serdarbalciold/histopathRprojects/ClinicoPath/data/melanoma.csv")

usethis::use_data(melanoma)


rocdata <- readr::read_csv(file = 
"/Users/serdarbalciold/histopathRprojects/ClinicoPath/data/rocdata.csv")

usethis::use_data(rocdata)

histopathology <- readr::read_csv(file = 
"/Users/serdarbalciold/histopathRprojects/ClinicoPath/data/histopathology.csv")

usethis::use_data(histopathology)


```

## force git

```{r force git, eval=FALSE, include=FALSE}
# gitUpdateCommitPush
CommitMessage <- paste("updated on ", Sys.time(), sep = "")
wd <- getwd()
gitCommand <- paste("cd ", wd, " \n git add . \n git commit --message '", CommitMessage, "' \n git push origin master \n", sep = "")
system(command = gitCommand, intern = TRUE)

```



## update project for release



```{r update project for release}
# jsurvival update project for release
source(file = here::here("tododata/update_jsurvival.R"))

setwd(here::here())

# ClinicoPathDescriptives  update project for release
source(file = here::here("tododata/update_ClinicoPathDescriptives.R"))

setwd(here::here())

# jjstatsplot update project for release
source(file = here::here("tododata/update_jjstatsplot.R"))

setwd(here::here())

# meddecide ClinicoPath project for release
source(file = here::here("tododata/update_meddecide.R"))

setwd(here::here())

# ClinicoPath update project for release
# source(file = here::here("tododata/update_ClinicoPath.R"))
# 
# setwd(here::here())
```



---

# Example


```{r read data}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))
```










```{r}
lubridate::is.Date(as.Date("2009-08-03"))

lubridate::is.Date(lubridate::as_date("2009-08-03"))


lubridate::is.Date(as.Date(deneme$SurgeryDate))

lubridate::is.Date(lubridate::as_date(deneme$SurgeryDate))

lubridate::is.Date(lubridate::as_date(deneme$Age))

lubridate::is.Date(deneme$SurgeryDate)

class(deneme$SurgeryDate)

typeof(deneme$SurgeryDate)

inherits(deneme$Age, c("POSIXct","POSIXt"))

inherits(deneme$SurgeryDate, c("POSIXct","POSIXt"))

```





```{r }
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

contin <- c("integer", "numeric", "double")

deneme$ID

inherits(deneme$ID, contin)

c(1,0) %in% c(0,1)

c(0,0) %in% c(0,1)

c(0,1) %in% c(0,1)

unique(c(0,1,2,3)) %in% c(0,1)

sum(unique(deneme$ID) %in% c(0,1)) == 0


asd <- c(0:234, NA)

asd <- c(0,1,2, NA)

asd <- c(0, NA)

asd <- c(1, NA)

asd <- c(0,1,NA)

all(asd %in% c(0,1), na.rm = TRUE)

!any(asd != 0, na.rm = TRUE) && !any(asd != 1, na.rm = TRUE)


unique(asd[!is.na(asd)]) %in% c(0,1)


`%notin%` <- Negate(`%in%`)
'a' %notin% c('b', 'c')

unique(asd[!is.na(asd)]) %notin% c(0,1)

length(unique(asd))


sum(unique(asd[!is.na(asd)]))

(unique(outcome1[!is.na(outcome1)]) %in% c(0,1)))


length(asd[!is.na(asd)]) == 2 && unique(asd[!is.na(asd)]) %in% c(0,1)
```


```{r }
# if ( !all(outcome1 %in% c(0,1), na.rm = TRUE) || !any(outcome1 != 0, na.rm = TRUE) || !any(outcome1 != 1, na.rm = TRUE)
                # ) {
                #     stop('When using continuous variable as an outcome, it must only contain 1s and 0s. If patient is dead or event (recurrence) occured it is 1. If censored (patient is alive or free of disease) at the last visit it is 0.')
                #
                # }






    # # Check if outcome variable is suitable or stop
                # myoutcome2 <- self$options$outcome
                # myoutcome2 <- self$data[[myoutcome2]]
                # myoutcome2 <- na.omit(myoutcome2)
                # # if ( !is.numeric(myoutcome2) || any(myoutcome2 != 0 & myoutcome2 != 1))
                # if (any(myoutcome2 != 0 & myoutcome2 != 1))
                #     stop('Outcome variable must only contains 1s and 0s. If patient is dead or event (recurrence) occured it is 1. If censored (patient is alive or free of disease) at the last visit it is 0.')
                # # self$results$deneme$setContent(head(mydata))
                # # self$results$deneme2$setContent(head(mydata))


```





```{r read data}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

library(magrittr)

deneme %$% table()

```






```{r read data}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

ggstatsplot::gghistostats(iris,
                          x = Sepal.Length ,
                          ggtheme = NULL,
                          ggstatsplot.layer = FALSE
                          )


```





```{r}
library(magrittr)

myvar <- deneme$LVI


# The data contains 250 observations of the following variables:
#   - Group: 2 levels: Control (n = 120, 48.00%); Treatment (n = 129, 51.60%) and missing (n = 1, 0.40%)
#   - Sex: 2 levels: Male (n = 128, 51.20%); Female (n = 121, 48.40%) and missing (n = 1, 0.40%)





unique(deneme$LVI)

leng <- length(deneme$LVI)

for (fac in facs)
            data[[fac]] <- as.factor(data[[fac]])

miss <- sum(is.na(deneme$LVI))

valid <- leng - miss

nlev <- nlevels(as.factor(deneme$LVI))

unique(as.factor(deneme$LVI))



summar <- summary(as.factor(deneme$LVI)) %>% 
as.table() %>%
  tibble::as_tibble(.name_repair = "unique") %>% 
    dplyr::filter(.[[1]] != "NA's") 

summar$validtotal <- valid


description <- summar %>% 
    dplyr::mutate(
        percent = n/validtotal
        ) %>% 
    dplyr::mutate(
        description = glue::glue(
            "{...1}: n = {n}, {scales::percent(percent)}"
                            )
                    ) %>%
                    dplyr::select(description) %>%
                    dplyr::pull()



paste0(
    myvar, " has ", leng, " observations and ", nlev, " levels.",
    unlist(description),
    "There are ", miss, "missing values."
       )


# catsummary function
catsummary <- function(myvar) {

    
    



            }
```






```{r report}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

library(magrittr)

corx <- deneme %>%
                dplyr::select(Age, OverallTime) %>% 
                stats::cor(method = "spearman") %>%
                report::report()

```








```{r inherits}
inherits(deneme$Sex, "character")
```

```{r betweenstats}
ggstatsplot::ggbetweenstats(data = deneme,
                            x = Sex,
                            y = Age,
                            type = "p")

ClinicoPath::statsplot2(
    data = deneme,
    dep = Age,
    group = Sex)
```




```{r writesummary, eval=FALSE, include=FALSE}
devtools::install(upgrade = FALSE, quick = TRUE)
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

# library("ClinicoPath")

deneme$Age <- as.numeric(as.character(deneme$Age))

ClinicoPath::writesummary(data = deneme, vars = Age)

ggstatsplot::normality_message(deneme$Age, "Age")


ClinicoPath::writesummary(
    data = deneme,
    vars = Age)


```



```{r finalfit, eval=FALSE, include=FALSE}
devtools::install(upgrade = FALSE, quick = TRUE)
library(dplyr)
library(survival)
library(finalfit)
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))
ClinicoPath::finalfit(data = deneme,
                      explanatory = Sex,
                      outcome = Outcome,
                      overalltime = OverallTime)
```



```{r decision, eval=FALSE, include=FALSE}
devtools::install(upgrade = FALSE, quick = TRUE)
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

ClinicoPath::decision(
    data = deneme,
    gold = Outcome,
    goldPositive = "1",
    newtest = Smoker,
    testPositive = "TRUE")

ClinicoPath::decision(
    data = deneme,
    gold = LVI,
    goldPositive = "Present",
    newtest = PNI,
    testPositive = "Present")
```

```{r eval=FALSE, include=FALSE}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))
ggstatsplot::ggbetweenstats(data = deneme, 
                            x = LVI,
                            y = Age)

```





```{r statsplot, eval=FALSE, include=FALSE}
devtools::install(upgrade = FALSE, quick = TRUE)
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))
ClinicoPath::statsplot(
    data = deneme,
    dep = Age,
    group = Smoker)
```




```{r decision 2, eval=FALSE, include=FALSE}
mytable <- table(deneme$Outcome, deneme$Smoker)

caret::confusionMatrix(mytable)
confusionMatrix(pred, truth)
confusionMatrix(xtab, prevalence = 0.25)

levels(deneme$Outcome)

mytable[1,2]

d <- "0"

mytable[d, "FALSE"]

mytable[[0]]

```











```{r construct formula, eval=FALSE, include=FALSE}
formula <- jmvcore::constructFormula(terms = c("A", "B", "C"))

jmvcore::constructFormula(terms = list("A", "B", "C"))

vars <- jmvcore::decomposeFormula(formula = formula) 

vars <- jmvcore::decomposeTerms(vars)


vars <- unlist(vars)

formula <- as.formula(formula)


my_group <- "lvi"

jmvcore::composeTerm(my_group)


my_dep <- "age"

formula <- paste0('x = ', group, 'y = ', dep)
myformula <- as.formula(formula)

myformula <- glueformula::gf({my_group}, {my_dep})

myformula <- glue::glue( 'x = ' , {my_group}, ', y = ' , {my_dep})

myformula <- jmvcore::composeTerm(myformula)


```


```{r}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

library(survival)
km_fit <- survfit(Surv(OverallTime, Outcome) ~ LVI, data = deneme)

library(dplyr)
km_fit_median_df <- summary(km_fit)
km_fit_median_df <- as.data.frame(km_fit_median_df$table) %>%
                janitor::clean_names(dat = ., case = "snake") %>%
                tibble::rownames_to_column(.data = ., var = "LVI")


KMunicate::KMunicate(fit = km_fit,
                             time_scale = time_scale
                             )


```


```{r}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

library(survival)
library(survminer)

# km_fit <- survfit(Surv(OverallTime, Outcome) ~ LVI, data = deneme)

res.cut <- survminer::surv_cutpoint(
  deneme,
  time = "OverallTime",
  event = "Outcome",
  "Age",
  minprop = 0.1,
  progressbar = TRUE
)

res.cut$Age

res.cut$data

res.cut$minprop

res.cut$cutpoint

summary(res.cut)


plot(res.cut, "Age", palette = "npg")


res.cat <- surv_categorize(res.cut)


fit <- survfit(Surv(OverallTime, Outcome) ~ Age, data = res.cat)
ggsurvplot(fit, data = res.cat, risk.table = TRUE, conf.int = TRUE)


```



```{r construct formula 2, eval=FALSE, include=FALSE}
library(dplyr)
library(survival)

deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

myoveralltime <- deneme$OverallTime
myoutcome <- deneme$Outcome
myexplanatory <- deneme$LVI

class(myoveralltime)
class(myoutcome)
typeof(myexplanatory)

is.ordered(myexplanatory)

formula2 <- jmvcore::constructFormula(terms = "myexplanatory")
# formula2 <- jmvcore::decomposeFormula(formula = formula2)
# formula2 <- paste("", formula2)
# formula2 <- as.formula(formula2)
formula2 <- jmvcore::composeTerm(formula2)


formulaL <- jmvcore::constructFormula(terms = "myoveralltime")
# formulaL <- jmvcore::decomposeFormula(formula = formulaL)

formulaR <- jmvcore::constructFormula(terms = "myoutcome")
# formulaR <- jmvcore::decomposeFormula(formula = formulaR)

formula <- paste("Surv(", formulaL, ",", formulaR, ")")
# formula <- jmvcore::composeTerm(formula)
# formula <- as.formula(formula)
# jmvcore::constructFormula(terms = c(formula, formula2))

deneme %>%
  finalfit::finalfit(formula, formula2) -> tUni

tUni
```



```{r}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

library(survival)

# res.cox <- coxph(Surv(OverallTime, Outcome) ~ LVI, data = deneme)



finalfit::finalfit(.data = deneme,
                dependent = 'Surv(OverallTime, Outcome)',
                explanatory = c("LVI", "Grade")

                # metrics = TRUE
                ) -> tCox

# tCox_df1 <- as.data.frame(tCox)

tCox_df <- tibble::as_tibble(tCox, .name_repair = "minimal") %>%
    janitor::clean_names(dat = ., case = "snake")

names(tCox_df) <- names(data_frame) <- c(
                    "Explanatory",
                    "Levels",
                    "all",
                    "HR_univariable",
                    "HR_multivariable"
                    )

tCox_df

indexexplanatory <- which(tCox_df$Explanatory != '')

indexexplanatory <- tCox_df$Levels[indexexplanatory]



# https://stackoverflow.com/questions/38470355/r-fill-empty-cell-with-value-of-last-non-empty-cell

while(length(ind <- which(tCox_df$Explanatory == "")) > 0){
  tCox_df$Explanatory[ind] <- tCox_df$Explanatory[ind - 1]
}


# tCox_df %>% 
#     dplyr::group_by(Explanatory) %>%
#     dplyr::mutate(llag = lag(Levels)) %>% 
#     dplyr::mutate(
#         glue::glue(
#             "When {Explanatory} is {Levels}, there is {HR_multivariable} times risk than when {Explanatory} is {llag}."
#         )
#     )



tCox_df %>% 
    dplyr::group_by(Explanatory) %>%
    dplyr::mutate(llag = first(Levels)) %>% 
    dplyr::mutate(
        coxdescription = glue::glue(
            "When {Explanatory} is {Levels}, there is {HR_multivariable} times risk than when {Explanatory} is {llag}."
        )
    ) %>% 
    dplyr::filter(HR_univariable != '-') %>% 
    dplyr::pull(coxdescription) %>% 
    unlist()


```


```{r}
# https://stackoverflow.com/questions/38470355/r-fill-empty-cell-with-value-of-last-non-empty-cell

while(length(ind <- which(tCox_df$dependent_surv_overall_time_outcome == "")) > 0){
  tCox_df$dependent_surv_overall_time_outcome[ind] <- tCox_df$dependent_surv_overall_time_outcome[ind -1]
}

tCox_df

tCox_descr <- function(n) {
                    paste0(
                        "When ",
                        data_frame$dependent_surv_overall_time_outcome[n+1],
                        " is ",
                        data_frame$x[n + 1],
                        ", there is ",
                        data_frame$hr_univariable[n + 1],
                        " times risk than ",
                        "when ",
                        data_frame$dependent_surv_overall_time_outcome[n+1],
                        " is ",
                        data_frame$x[n],
                        "."
                    )
                }


purrr::map(.x = c(1:3), .f = tCox_descr)

tCox_df %>% 
split(.$dependent_surv_overall_time_outcome) %>% 
    purrr::map(dim)

tCox_df %>% 
    group_by(dependent_surv_overall_time_outcome) %>% 
    dim()

tCox_descr <- function(df) {
    
    n <- dim(df)[1]
    
    describe <-  paste0(
                        "When ",
                        df$dependent_surv_overall_time_outcome[n],
                        " is ",
                        df$x[n],
                        ", there is ",
                        df$hr_univariable[n],
                        " times risk than ",
                        "when ",
                        df$dependent_surv_overall_time_outcome[n],
                        " is ",
                        df$x[n],
                        ".")
    
    return(describe)
}


finalfit::finalfit(.data = deneme,
                dependent = 'Surv(OverallTime, Outcome)',
                explanatory = c("LVI")

                # metrics = TRUE
                ) -> tCox

tCox_df2 <- as.data.frame(tCox)

tCox_descr(tCox_df2)

```







```{r}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

library(survival)
km_fit <- survfit(Surv(OverallTime, Outcome) ~ LVI + PNI, data = deneme)

```












```{r eval=FALSE, include=FALSE}
library(dplyr)
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

results <- deneme %>%
                ggstatsplot::ggbetweenstats(LVI, Age)
results

mydep <- deneme$Age
mygroup <- deneme$LVI


mygroup <- jmvcore::constructFormula(terms = "mygroup")
mygroup <- jmvcore::composeTerm(mygroup)

mydep <- jmvcore::constructFormula(terms = "mydep")
mydep <- jmvcore::composeTerm(mydep)


# not working
# eval(mygroup)
# rlang::eval_tidy(mygroup)
# !!mygroup
# {{mygroup}}
# sym(mygroup)
# quote(mygroup)
# enexpr(mygroup)

mygroup <- jmvcore::constructFormula(terms = "mygroup")
mydep <- jmvcore::constructFormula(terms = "mydep")

formula1 <- paste(mydep)
formula1 <- jmvcore::composeTerm(formula1)


mygroup <- paste(mygroup)
mygroup <- jmvcore::composeTerm(mygroup)

mydep <- deneme$Age
mygroup <- deneme$LVI

mydep <- jmvcore::resolveQuo(jmvcore::enquo(mydep))
mygroup <- jmvcore::resolveQuo(jmvcore::enquo(mygroup))

mydata2 <- data.frame(mygroup=mygroup, mydep=mydep)

results <- mydata2 %>%
                ggstatsplot::ggbetweenstats(
x = mygroup, y = mydep  )

results



myformula <- glue::glue('x = ', {mygroup}, ', y = ' , {mydep})

myformula <- jmvcore::composeTerm(myformula)

myformula <- as.formula(myformula)
















mydep2 <- quote(mydep)
mygroup2 <- quote(mygroup)


results <- deneme %>%
                ggstatsplot::ggbetweenstats(!!mygroup2, !!mydep2)
results
```








```{r construct formula 3, eval=FALSE, include=FALSE}
formula <- jmvcore::constructFormula(terms = c("myoveralltime", "myoutcome"))

vars <- jmvcore::decomposeFormula(formula = formula) 


explanatory <- jmvcore::constructFormula(terms = c("explanatory"))    

explanatory <- jmvcore::decomposeFormula(formula = explanatory)

explanatory <- unlist(explanatory)

myformula <- paste("Surv(", vars[1], ", ", vars[2], ")")



deneme %>%
finalfit::finalfit(myformula, explanatory) -> tUni

```


```{r table tangram}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))



tabletangram <-
                    tangram::html5(
                        tangram::tangram(
                            "Death ~ LVI + PNI + Age", deneme,
                            transform=tangram::hmisc,
                            id = "tbl3",
                            digits = 1,
                            test = TRUE,
                            include_p = TRUE
                        ),
                        fragment = TRUE,
                        style = "nejm",
                        caption = paste0(
                            "Cross Table for Dependent "
                            ),
                        id = "tbl3")

tabletangram

```


```{r table tangram}
table3 <-
  tangram::html5(
    tangram::tangram(
      "Death ~ LVI + PNI + Age", deneme),
    fragment=TRUE,
    # style = "hmisc",
    style = "nejm",
    # inline="nejm.css",
    caption = "HTML5 Table",
    id="tbl3")

table3

mydep <- deneme$Age
mygroup <- deneme$Death


formulaR <- jmvcore::constructFormula(terms =  c("LVI", "PNI", "Age"))

formulaL <- jmvcore::constructFormula(terms = "Death")

formula <- paste(formulaL, '~', formulaR)

# formula <- as.formula(formula)

sty <- jmvcore::composeTerm(components = "nejm")

gr <- jmvcore::composeTerm(components = "Death")


table <- tangram::html5(
    tangram::tangram(formula, deneme
                     ),
    fragment=TRUE,
    # style = "hmisc",
    # style = "nejm",
    style = sty,
    # inline="nejm.css",
    caption = paste0("HTML5 Table ", gr),
    id="tbl4")

table


```





```{r read data OR}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))


mydata <- deneme

formula2 <- jmvcore::constructFormula(terms = c("LVI", "PNI", "Age"))

formulaR <- jmvcore::constructFormula(terms = "Death")

formulaR <- jmvcore::toNumeric(formulaR)



plot <-
                finalfit::or_plot(
                    .data = mydata,
                    dependent = formulaR,
                    explanatory = formula2,
                    remove_ref = FALSE,
                    table_text_size = 4,
                    title_text_size = 14,
                    random_effect = NULL,
                    factorlist = NULL,
                    glmfit = NULL,
                    confint_type = NULL,
                    breaks = NULL,
                    column_space = c(-0.5, 0, 0.5),
                    dependent_label = "Death",
                    prefix = "",
                    suffix = ": OR (95% CI, p-value)",
                    table_opts = NULL,
                    plot_opts = list(
                    ggplot2::xlab("OR, 95% CI"),
                    ggplot2::theme(
                    axis.title = ggplot2::element_text(size = 12)
                    )
                    )
                    )


```







---

# Other Codes



## arsenal

```{r}
library(arsenal)

summary(tableby(sex ~ age + arm, data = mockstudy),
        text = "html",
        pfootnote = "html")




```




```{r arsenal, results='asis'}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

tab1 <- arsenal::tableby(
    LVI~ Age + Sex
    , data = deneme
                         )

# results <- summary(tab1
#                    , pfootnote = TRUE)
# 
# 
tablearsenal <- tab1

tablearsenal2 <- summary(tablearsenal,
                                        text = 'html',
                                        pfootnote = 'html')


# gregexpr(pattern = "^</table>\n.*$", text = tablearsenal2, perl = TRUE)

tablearsenal2 <- capture.output(tablearsenal2)




tablearsenal3 <-
kableExtra::kable(tablearsenal2,
format = "html",
digits = 1,
escape = TRUE
)
```


```{r arsenal, results='asis'}
sumtab <- summary(tab1
        , pfootnote = TRUE)

printsumtab <- print(sumtab)


# results$object
# results$control
# results$totals
# results$hasStrata
# results$text
# results$pfootnote
# results$term.name
# 
# tab1$Call
# 
# tab1$control

tab1$tables # this is where results lie


```


## define survival time

```{r define survival time, eval=FALSE, include=FALSE}
mydata$int <- lubridate::interval(
  lubridate::ymd(mydata$SurgeryDate),
  lubridate::ymd(mydata$LastFollowUpDate)
  )
mydata$OverallTime <- lubridate::time_length(mydata$int, "month")
mydata$OverallTime <- round(mydata$OverallTime, digits = 1)
```




## Multivariate Analysis Survival


```{r Multivariate Analysis, eval=FALSE, include=FALSE}
library(finalfit)
library(survival)
explanatoryMultivariate <- explanatoryKM
dependentMultivariate <- dependentKM

mydata %>%
  finalfit(dependentMultivariate, explanatoryMultivariate) -> tMultivariate

knitr::kable(tMultivariate, row.names=FALSE, align=c("l", "l", "r", "r", "r", "r"))
```


---

```{r}
# Find arguments in yaml

list_of_yaml <- c(
    list.files(path = "~/histopathRprojects/ClinicoPath-Jamovi--prep/jmv",
               pattern = "\\.yaml$",
               full.names = TRUE,
               all.files = TRUE,
               include.dirs = TRUE,
               recursive = TRUE
    )
)


text_of_yaml_yml <- purrr::map(
    .x = list_of_yaml,
    .f = readLines
)

text_of_yaml_yml <- as.vector(unlist(text_of_yaml_yml)) 

arglist <-
    stringr::str_extract(
        string = text_of_yaml_yml, 
        pattern = 
            "([[:alnum:]]*):"
    )

arglist <- arglist[!is.na(arglist)]
arglist <- unique(arglist)
arglist <- gsub(pattern = ":", # remove some characters
                    replacement = "",
                    x = arglist)
arglist <- trimws(arglist) # remove whitespace

cat(arglist, sep = "\n")

```






<!-- # -->
<!-- #                 # tUni_df_descr <- paste0("When ", -->
<!-- #                 #                         tUni_df$dependent_surv_overall_time_outcome[1], -->
<!-- #                 #                         " is ", -->
<!-- #                 #                         tUni_df$x[2], -->
<!-- #                 #                         ", there is ", -->
<!-- #                 #                         tUni_df$hr_univariable[2], -->
<!-- #                 #                         " times risk than ", -->
<!-- #                 #                         "when ", -->
<!-- #                 #                         tUni_df$dependent_surv_overall_time_outcome[1], -->
<!-- #                 #                         " is ", -->
<!-- #                 #                         tUni_df$x[1], -->
<!-- #                 #                         "." -->
<!-- #                 # ) -->
<!-- # -->
<!-- #                 # results5 <- tUni_df_descr -->


```{r}
boot::melanoma
rio::export(x = boot::melanoma, file = "data/melanoma.csv")

survival::colon
rio::export(x = survival::colon, file = "data/colon.csv")

# BreastCancerData <- "https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data"
# 
# BreastCancerNames <- "https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.names"
# 
# BreastCancerData <- read.csv(file = BreastCancerData, header = FALSE,
#                 col.names = c("id","CT", "UCSize", "UCShape", "MA", "SECS", "BN", "BC", "NN","M", "diagnosis") )

library(mlbench)

data("BreastCancer")
BreastCancer

rio::export(x = BreastCancer, file = "data/BreastCancer.csv")



```




```{r pairwise}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))
# names(deneme)
library(magrittr)

mypairwise <-  survminer::pairwise_survdiff(
                            formula = survival::Surv(OverallTime, Outcome) ~ TStage,
                            data = deneme,
                            p.adjust.method = "BH"
                            )


mypairwise2 <- as.data.frame(mypairwise[["p.value"]]) %>% 
  tibble::rownames_to_column()

mypairwise2 %>% 
  tidyr::pivot_longer(cols = -rowname) %>% 
  dplyr::filter(complete.cases(.)) %>% 
  dplyr::mutate(description =
                            glue::glue(
                                "The comparison between {rowname} and {name} has a p-value of {round(value, 2)}."
                            )
                    ) %>% 
                    dplyr::select(description) %>%
                    dplyr::pull() -> mypairwisedescription

mypairwisedescription <- unlist(mypairwisedescription)

mypairwisedescription <- c(
"In the pairwise comparison of",
mypairwisedescription)




```



```{r}
            # mydata <- self$data

            # mydep <- self$data[[self$options$dep]]
            # mygroup <- self$data[[self$options$group]]
            #
            #
            # plotData <- data.frame(gr = mygroup, dp = jmvcore::toNumeric(mydep))
            # plotData <- jmvcore::naOmit(plotData)
            #
            # image <- self$results$plot
            #
            # image$setState(plotData)


            # self$results$text1$setContent(plotData)


            # mydepType <- data.frame(vclass = class(mydep),
            #                         vtypeof = typeof(mydep),
            #                         vordered = is.ordered(mydep),
            #                         vfactor = is.factor(mydep),
            #                         vnumeric = is.numeric(mydep),
            #                         vdouble = is.double(mydep),
            #                         vcharacter = is.character(mydep),
            #                         vdate = lubridate::is.Date(mydep),
            #                         vdate2 = is.na.POSIXlt(mydep)
            #                         )
            # mygroupType <- class(mygroup)
            # variableTypes <- list(mydepType, mygroupType)
            # self$results$text1$setContent(variableTypes)

            # plotData <- image$state


            # https://indrajeetpatil.github.io/ggstatsplot/
            # ggbetweenstats 	violin plots 	for comparisons between groups/conditions
            # ggwithinstats 	violin plots 	for comparisons within groups/conditions
            #
            # ggdotplotstats 	dot plots/charts 	for distribution about labeled numeric variable
            #
            # ggbarstats 	bar charts 	for categorical data
            #
            # ggscatterstats 	scatterplots 	for correlations between two variables

            # http://corybrunson.github.io/ggalluvial/


            # plot <- ggplot(plotData, aes(x = gr,
            #                              y = dp)) +
            #     geom_point()

            # plot <- plotData %>%
            #     ggstatsplot::ggbetweenstats(
            #         x = gr,
            #         y = dp
            #         )
```




```{r read csv}
library(readr)
BreastCancer <- read_csv("data/BreastCancer.csv")
View(BreastCancer)
```





```{r}


mytarget <- "Class"
myvars <- c("Cl.thickness",
            "Cell.size",
            "Cell.shape",
            "Marg.adhesion",
            "Epith.c.size",
            "Bare.nuclei",
            "Bl.cromatin",
            "Normal.nucleoli",
            "Mitoses")

mydata <- BreastCancer %>% 
    select(., c(mytarget, myvars))

formula <- jmvcore::constructFormula(terms = mytarget)

formula <- paste(formula, '~ .')

formula <- as.formula(formula)

datn <- round(dim(mydata)[1] /10)

mydata_train <- mydata[1:datn, ]

mydata_test <- mydata[(datn+1):(dim(mydata)[1]), ]


 # Create an FFTrees object from the data
 FFTrees.fft <- FFTrees::FFTrees(
     formula = formula,
     data = mydata_train,
     data.test = mydata_test,
     main = mydata
     )

 # Plot the best tree applied to the test data
 plot2 <- plot(FFTrees.fft,
      data = mydata_test
      # ,
      # main = "Heart Disease",
      # decision.labels = c("Healthy", "Disease")
                 )
```





```{r}
devtools::install(upgrade = FALSE, quick = TRUE)


deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))


ClinicoPath::statsplotbetween(
    data = deneme,
    dep = LVI,
    group = PNI)
```


```{r}
myirr <- data.frame(
          Rater1 = c(0L,1L,1L,0L,0L,0L,1L,1L,1L,0L,1L,
                 1L,1L,1L,1L,0L,NA,1L,1L,0L,0L,1L,1L,1L,1L,1L,0L,
                 1L,1L,1L,1L,0L,1L,1L,1L,1L,1L,0L,0L,1L,1L,1L,
                 1L,1L,0L,1L,1L,1L,0L,0L,1L,1L,1L,0L,1L,1L,1L,0L,
                 1L,1L,0L,1L,0L,1L,1L,0L,0L,1L,0L,1L,1L,1L,0L,0L,
                 0L,0L,1L,1L,1L,0L,0L,1L,1L,1L,1L,0L,0L,0L,1L,0L,
                 0L,1L,1L,0L,1L,1L,0L,1L,1L,0L,1L,1L,0L,1L,1L,
                 0L,1L,1L,1L,0L,1L,1L,1L,0L,1L,1L,0L,0L,1L,0L,1L,
                 1L,1L,0L,1L,1L,1L,1L,1L,1L,1L,1L,0L,1L,1L,1L,1L,
                 1L,1L,1L,1L,1L,1L,0L,1L,1L,1L,1L,1L,1L,1L,0L,0L,
                 1L,0L,1L,1L,1L,1L,1L,0L,0L,1L,1L,1L,1L,1L,0L,
                 0L,0L,1L,1L,0L,1L,1L,0L,1L,0L,1L,1L,1L,0L,1L,1L,
                 1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,
                 0L,0L,1L,1L,1L,1L,0L,0L,1L,1L,0L,1L,1L,1L,0L,1L,
                 0L,1L,1L,1L,1L,0L,0L,0L,0L,1L,0L,1L,1L,1L,0L,
                 0L,1L,1L,1L,0L,1L,0L,0L,0L,1L,1L,1L,0L,1L,0L,0L,
                 0L,1L,1L),
          Rater2 = c(0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,
                 0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,1L,1L,1L,0L,
                 1L,1L,1L,1L,0L,1L,1L,1L,1L,1L,0L,0L,1L,1L,1L,
                 1L,1L,0L,1L,1L,1L,0L,0L,1L,1L,1L,0L,1L,1L,1L,0L,
                 1L,1L,0L,1L,0L,1L,1L,0L,0L,1L,0L,1L,1L,1L,0L,0L,
                 0L,0L,1L,1L,1L,0L,0L,1L,1L,1L,1L,0L,0L,0L,1L,0L,
                 0L,1L,1L,0L,1L,1L,0L,1L,1L,0L,1L,1L,0L,1L,1L,
                 0L,1L,1L,1L,0L,1L,1L,1L,0L,1L,1L,0L,0L,1L,0L,1L,
                 1L,1L,0L,1L,1L,1L,1L,1L,1L,1L,1L,0L,1L,1L,1L,1L,
                 1L,1L,1L,1L,1L,1L,0L,1L,1L,1L,1L,1L,1L,1L,0L,0L,
                 1L,0L,1L,1L,1L,1L,1L,0L,0L,1L,1L,1L,1L,1L,0L,
                 0L,0L,1L,1L,0L,1L,1L,0L,1L,0L,1L,1L,1L,0L,1L,1L,
                 1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,
                 0L,0L,1L,1L,1L,1L,0L,0L,1L,1L,0L,1L,1L,1L,1L,1L,
                 1L,1L,1L,1L,1L,1L,1L,1L,1L,1L,0L,1L,1L,1L,0L,
                 0L,1L,1L,1L,0L,1L,0L,0L,0L,1L,1L,1L,0L,1L,0L,0L,
                 0L,1L,1L)
)

myirr <- myirr %>% 
    dplyr::mutate(
        RaterA = dplyr::case_when(
            Rater1 == 0 ~ "Negative",
            Rater1 == 1 ~ "Positive"
        )
    ) %>% 
    dplyr::mutate(
        RaterB = dplyr::case_when(
            Rater2 == 0 ~ "Negative",
            Rater2 == 1 ~ "Positive"
        )
    ) %>% 
    dplyr::select(RaterA, RaterB) %>% 
    mutate(RaterA = as.factor(RaterA)) %>% 
    mutate(RaterB = as.factor(RaterB))

table <- myirr %$% 
table(RaterA, RaterB)

mymatrix <- caret::confusionMatrix(table, positive = "Positive")
mymatrix

caret::sensitivity(table, positive = "Positive")


mymatrix2 <- caret::confusionMatrix(table, positive = "Positive", prevalence = 0.25)
mymatrix2


```


```{r epiR}
 dat <- as.table(
                matrix(c(670,202,74,640),
                       nrow = 2,
                       byrow = TRUE)
                )

            colnames(dat) <- c("Dis+","Dis-")
            rownames(dat) <- c("Test+","Test-")

            rval <- epiR::epi.tests(dat, conf.level = 0.95)

            rval <- list(
                dat,
                rval,
                print(rval),
                summary(rval)
                         )

rval[[1]]
rval[[2]]
rval[[2]][["conf.level"]]
rval[[2]][["elements"]]
rval[[2]][["rval"]]
rval[[2]][["tab"]]
rval[[4]]

            
            
            
            
```








```{r irr agreement}
devtools::install(upgrade = FALSE, quick = TRUE)
library(dplyr)

deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

ratings <- deneme %>% 
    dplyr::select(LVI, PNI, Age, ID)


f <- unlist(lapply(ratings, class))

any(f == "numeric")

all(f == "numeric")


xtitle <- names(ratings)[1]
ytitle <- names(ratings)[2]

result <- table(ratings[,1], ratings[,2],
                dnn = list(xtitle, ytitle))

table(ratings)



result1 <- irr::agree(ratings)


result2 <- irr::kappa2(ratings)


ClinicoPath::agreement(
    data = deneme,
    vars = c(LVI,PNI)
)


result2 <- irr::kappam.fleiss(
                    ratings = ratings,
                    exact = FALSE,
                    detail = TRUE)



```

```{r}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

x <- "Race"
x <- jmvcore::composeTerm(x)

y1 <- "Asian"
y1 <- jmvcore::composeTerm(y1)


y2 <- "Black"
y2 <- NULL
y2 <- jmvcore::composeTerm(y2)


xprunebelow <-  paste0("list(", x,"=c('", y1, "','", y2,"'))")

vtree::vtree(deneme,
             "Race LVI",
             prunebelow = eval(parse(text = xprunebelow))
)

```


```{r}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

mytree <- vtree::vtree(deneme, "LVI PNI", width = '100pt')

# write(mytree[["x"]][["diagram"]], 
#       file = here::here("/tododata/trial1.gv"))

# DiagrammeR::grViz(diagram = here::here("/tododata/trial1.gv"))

diagram <- mytree[["x"]][["diagram"]]

mytree2 <- DiagrammeR::grViz(diagram = diagram)

DiagrammeRsvg::export_svg(gv = mytree)

```









# Packages for Development



---


## rpkgtools


devtools::install_github("IndrajeetPatil/rpkgtools")



## available


Check if a package name is available to use https://docs.ropensci.org/available


https://github.com/r-lib/available


```{r eval=FALSE, include=FALSE}
available::available("clinicopath")
available::available("lens2r")

```



## bench


High Precision Timing of R Expressions http://bench.r-lib.org/

https://github.com/r-lib/bench






## desc


Manipulate DESCRIPTION files
https://github.com/r-lib/desc



## pkgverse

pkgverse: Build a Meta-Package Universe
https://pkgverse.mikewk.com/



## pkgbuild

pkgbuild: Find Tools Needed to Build R Packages
https://github.com/r-lib/pkgbuild


## pkgload

pkgload: Simulate Package Installation and Attach
https://github.com/r-lib/pkgload


## rcmdcheck

rcmdcheck: Run 'R CMD check' from 'R' and Capture Results
https://github.com/r-lib/rcmdcheck




## remotes


## sessioninfo

Print Session Information

https://github.com/r-lib/sessioninfo



## "covr




## "exampletestr


## "covrpage",


## "gramr",


## "lintr",


## "goodpractice",


## "pkgdown",


## "usethis",


## "testthat",


## "spelling",


## "RTest",

https://towardsdatascience.com/rtest-pretty-testing-of-r-packages-50f50b135650


## "rhub",


## "roxygen2",


## "sinew",


## "styler",



## "vdiffr"




## "attachment (https://github.com/ThinkR-open/attachment)
## "covrpage (https://github.com/yonicd/covrpage)
## "defender (https://github.com/ropenscilabs/defender)
## "gramr (https://github.com/ropenscilabs/gramr)
## "packagemetrics (https://github.com/ropenscilabs/packagemetrics)
## "pRojects (https://github.com/lockedata/pRojects)
## "revdepcheck (https://github.com/r-lib/revdepcheck)
## "roxygen2Comment (https://github.com/csgillespie/roxygen2Comment)
## "roxygen2md (https://github.com/r-lib/roxygen2md)
## "testdown (https://github.com/ThinkR-open/testdown)
## "tic (https://github.com/ropenscilabs/tic)





---



```{r}
            # Table1 <- table(mydata[[testVariable]], mydata[[goldVariable]])


            # Table1 <- mydata %>%
            #     janitor::tabyl(.data[[testVariable]], .data[[goldVariable]]) %>%
            #     janitor::adorn_totals(dat = ., where = c("row", "col")) %>%
            #     janitor::adorn_percentages(dat = ., denominator = "row") %>%
            #     janitor::adorn_percentages(dat = ., denominator = "col") %>%
            #     janitor::adorn_pct_formatting(dat = ., rounding = "half up", digits = 1) %>%
            #     janitor::adorn_ns(dat = .) %>%
            #     janitor::adorn_title("combined")
            # results1 <- Table1
```


```{r}
                # results1 <- summary(km_fit)$table

                # km_fit_median_df <- summary(km_fit)
                # km_fit_median_df <- as.data.frame(km_fit_median_df$table) %>%
                #     janitor::clean_names(dat = ., case = "snake") %>%
                #     tibble::rownames_to_column(.data = .)

                # results1 <- tibble::as_tibble(results1,
                #                              .name_repair = "minimal") %>%
                #     janitor::clean_names(dat = ., case = "snake") %>%
                #     tibble::rownames_to_column(.data = ., var = self$options$explanatory)
```








```{r decision}

table2 <- matrix(c(80, 20, 30, 70), nrow = 2, ncol = 2, byrow = TRUE, dimnames = list(c("Positive", "Negative"), c("Positive","Negative")))

            table3 <- as.table(table2)

            names(attributes(table3)$dimnames) <- c("Test","Gold Standart")

caretresult <- caret::confusionMatrix(table3, mode = "everything")



table4 <- as.data.frame(table3)

library("magrittr")

table5 <- table4 %>% 
    dplyr::mutate(
        Test = dplyr::case_when(
            Test == "Positive" ~ "Test Positive",
            Test == "Negative" ~ "Test Negative"
        )) %>% 
         dplyr::mutate(
        Gold.Standart = dplyr::case_when(
            Gold.Standart == "Positive" ~ "Gold Standart Positive",
            Gold.Standart == "Negative" ~ "Gold Standart Test Negative"
        ))   


table6 <- table5 %>%
    tidyr::pivot_wider(data = .,
                       names_from = Test,
                       values_from = Freq)


```


```{r}
table3 <- matrix(c(80L, 20L, 25L, 30L, 70L, 75L), nrow = 2, ncol = 3, byrow = TRUE)


# RVAideMemoire::chisq.multcomp() RVAideMemoire::fisher.multcomp()

result1 <- RVAideMemoire::chisq.multcomp(table3)

result1 <- result1[["p.value"]]


result1 <- as.data.frame(result1) %>%
                                tibble::rownames_to_column()

result1 <- result1 %>%
    tidyr::pivot_longer(cols = -rowname) %>%
    dplyr::filter(complete.cases(.))




myfun <- function(i,j) {
    if(!is.na(result1[i,j])){
    paste0(    
dimnames(result1)[[1]][i],
" vs ",
dimnames(result1)[[2]][j],
" p= ",    
result1[i,j])
    }
}

for (i in 1:dim(result1)[1]) {
for (j in 1:dim(result1)[2]) {
    des <- myfun(i,j)
    if(!is.null(des)) print(des)
}
}


myfun1 <- function(i,j) {
    if(!is.na(result1[i,j])){
dimnames(result1)[[1]][i]
    }
}


for (i in 1:dim(result1)[1]) {
for (j in 1:dim(result1)[2]) {
    des <- myfun1(i,j)
    if(!is.null(des)) print(des)
}
}





myfun(3,3)

myfun(1,2)


dimnames(result1)[[1]][2]


RVAideMemoire::fisher.multcomp(table3)


# rmngb::pairwise.chisq.test(x, ...)  rmngb::pairwise.fisher.test(x, ...)


library(rmngb)
x <- sample(1:2, 1e3, TRUE)
g <- sample(1:4, 1e3, TRUE)
result2 <- rmngb::pairwise.chisq.test(x, g)
tab <- table(g, x)

resultrmngb <- rmngb::pairwise.fisher.test(tab, p.adj = "bonf")

result2[["p.value"]]
resultrmngb[["p.value"]]

rmngb::pairwise.chisq.test(tab)


```



 
formula <- jmvcore::constructFormula(terms = self$options$vars)
formula <- paste('~', formula)
formula <- as.formula(formula)
table1 <- arsenal::tableby(formula, self$data,
total = TRUE,
digits = 1,
digits.count = 1
)
myarsenal <- summary(table1, text = "html")
myarsenal <- kableExtra::kable(myarsenal, format = "html",
digits = 1,
escape = TRUE) %>%
kableExtra::kable_styling(kable_input = .,
bootstrap_options = "striped",
full_width = F,
position = "left")


```{r}
library(dplyr)

deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))


varsName <- c("LVI", "PNI")

tablelist <- list()

                for (i in 1:length(varsName)) {

                    var <- varsName[i]
                    
                    
                    table <- deneme %>%
                        janitor::tabyl(dat = ., all_of(var)) %>%
                        janitor::adorn_totals("row") %>%
                        janitor::adorn_pct_formatting(dat = .)

                    tablelist[[i]] <- table

                }

tablelist


deneme %>%   
    janitor::tabyl(dat = ., LVI, PNI)


```





            data <- self$data

            vars <- self$options$vars

            facs <- self$options$facs

            target <- self$options$target

            # data <- jmvcore::select(data, c(vars, facs, target))


            if ( ! is.null(vars))
            for (var in vars)
                data[[var]] <- jmvcore::toNumeric(data[[var]])

            if ( ! is.null(facs))
            for (fac in facs)
                data[[fac]] <- as.factor(data[[fac]])


            data[[target]] <- as.factor(data[[target]])

            data <- jmvcore::naOmit(data)
            
            
            
            
            

            # TODO

            # todo <- glue::glue(
            #     "This Module is still under development
            #     -
            #     -
            #     "
            # )

            # self$results$todo$setContent(todo)

            # if (nrow(self$data) == 0)
            #     stop('Data contains no (complete) rows')


            # if (is.null(self$options$vars) || is.null(self$options$target))
            #     return()


            # prepare data for explore ----
            # https://cran.r-project.org/web/packages/explore/vignettes/explore.html


            # result1 <- iris %>% explore::explain_tree(target = Species)
            #
            # self$results$text1$setContent(result1)


            # image <- self$results$plot

            # image$setState(plotData)



            # from https://forum.jamovi.org/viewtopic.php?f=2&t=1287
            # library(caret)
            # library(partykit)
            # detach("package:partykit", unload=TRUE)
            # library(party)

            # Conditional Trees

            # set.seed(3456)
            # model <- train(
            #     yvar ~ .,
            #     data = df,
            #     method = 'ctree2',
            #     trControl = trainControl("cv", number = 10, classProbs = FALSE),
            #     tuneGrid = expand.grid(maxdepth = 3, mincriterion = 0.95)
            # )
            # plot(model$finalModel)
            #
            # t(sapply(unique(where(model$finalModel)), function(x) {
            #     n <- nodes(model$finalModel, x)[[1]]
            #     yvar <- df[as.logical(n$weights), "yvar"]
            #     cbind.data.frame("Node" = as.integer(x),
            #                      psych::describe(yvar, quant=c(.25,.50,.75), skew = FALSE))
            # }))
            
            
            
            
            


            # data <- private$.cleanData()

            # vars <- self$options$vars
            # facs <- self$options$facs
            # target <- self$options$target

            # tree1 <- data %>%
            #     explore::explain_tree(target = .data[[target]])




            # if (is.null(self$options$vars) || is.null(self$options$target))
            #     return()


            # varsName <- self$options$vars
            #
            # facsName <- self$options$facs
            #
            # targetName <- self$options$target
            #
            # data <- jmvcore::select(self$data, c(varsName, facsName, targetName))
            #
            # data[[varsName]] <- jmvcore::toNumeric(data[[varsName]])
            #
            # for (fac in facsName)
            #     data[[facsName]] <- as.factor(data[[facsName]])
            #
            # data <- jmvcore::naOmit(data)




            # tree1 <- data %>%
            #     explore::explain_tree(target = .data[[targetName]])


            # plot <- iris %>% explore::explain_tree(target = Species)
            # if (length(self$options$dep) + length(self$options$group) < 2)
            #     return()

            # tree1 <- iris %>% explore::explain_tree(target = Species)
            # iris$is_versicolor <- ifelse(iris$Species == "versicolor", 1, 0)
            # tree2 <- iris %>%
            # dplyr::select(-Species) %>%
            # explore::explain_tree(target = is_versicolor)
            # tree3 <- iris %>%
            # explore::explain_tree(target = Sepal.Length)









```{r explore}
library(magrittr)
# devtools::install(upgrade = FALSE, quick = TRUE)
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

mydata <- deneme

varsName <- "Age"

# facsName <- c("LVI", "PNI")

targetName <- "Outcome"

mydata[[targetName]] <- as.factor(mydata[[targetName]])

mydata <- jmvcore::select(mydata, c(varsName, 
                                    # facsName, 
                                    targetName))

mydata <- jmvcore::naOmit(mydata)



explore::explain_tree(data = mydata,
                      target = targetName
                      )

mydata %>%
explore::explain_tree(target = .data[[targetName]])
```



```{r explore 2}
iris %>% explore::explain_tree(target = Species)




BreastCancer %>%
                dplyr::select(all_of(mytarget), all_of(myvars)) %>%
                explore::explain_tree(target = .data[[mytarget]])




ClinicoPath::tree(
    data = data,
    vars = Age,
    facs = vars(LVI, PNI),
    target = Mortality)





```








<!-- mytarget <- "Class" -->
<!-- myvars <- c("Cl.thickness", -->
<!--             "Cell.size", -->
<!--             "Cell.shape", -->
<!--             "Marg.adhesion", -->
<!--             "Epith.c.size", -->
<!--             "Bare.nuclei", -->
<!--             "Bl.cromatin", -->
<!--             "Normal.nucleoli", -->
<!--             "Mitoses") -->

<!-- # mytarget <- jmvcore::composeTerms(mytarget) -->
<!-- # mytarget <- jmvcore::constructFormula(terms = mytarget) -->



```{r easyalluvial}
# install.packages("easyalluvial")
library(magrittr)
# devtools::install(upgrade = FALSE, quick = TRUE)
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

mydata <- deneme

var1 <- "TStage"

var2 <- "Grade"

mydata <- jmvcore::select(df = mydata, columnNames = c(var1, var2))

mydata <- jmvcore::naOmit(mydata)

plot <- 
easyalluvial::alluvial_wide( data = mydata
                , max_variables = 5
                , fill_by = 'first_variable'
                , verbose = TRUE
                )

plot %>% 
    easyalluvial::add_marginal_histograms(mydata)



```




## Diagrams


```{r eval=FALSE, include=FALSE}
echo=FALSE
DiagrammeR::grViz(
  diagram = here::here("vignettes/graph.gv"),
  height = 200
)
```



```{r eval=FALSE, include=FALSE}
DiagrammeR::mermaid(
  diagram = here::here("vignettes/graph.mmd"),
  height = 200
)
```




```{r read data}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

dp <- "LVI"

dp <- jmvcore::composeTerm(components = dp)

gr <- "PNI"

gr <- jmvcore::composeTerm(components = gr)

plot <- deneme %>% 
    ggstatsplot::ggbarstats(data = .,
                                main = .data[[dp]],
                                condition = .data[[gr]]
                )

```


```{r}
library(ggstatsplot)
library(patchwork)

deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

mydata <- deneme

dep <- c("LVI", "PNI", "Death")

dep <- as.vector(dep)

group <- "PreinvasiveComponent"

group <- jmvcore::composeTerm(components = group)


# running the same analysis on two different columns (creates a list of plots)

plotlist <-
purrr::pmap(
    .l = list(
        main = dep,
        # title = list(dep),
        messages = FALSE
    ),
    .f = ggstatsplot::ggpiestats,
    data = mydata,
    condition = !!group
)






# combine plots using `patchwork`
# plot2 <- plotlist[[1]] / plotlist[[2]]

plotname <- "plotlist[[1]] + "

if ( length(plotlist) > 1 ) {
    
for (i in 2:length(plotlist)) {
    newplot <- paste0("plotlist[[", i, "]]")
    plotname <- paste(plotname, newplot, sep = " + ")
}
    
}


# plotname

# plot2 <- paste0("plotlist[[1]] ", "+", " plotlist[[2]]")

plot2 <- eval(parse(text = plotname))

plot2

# if (group == "") group <- NULL
# plot2 <-
#     ggstatsplot::ggpiestats(
#         data = mydata,
#         main = !!dep,
#         condition = !!group
#     )


# 
# dp <- "LVI"
# 
# dp <- jmvcore::composeTerm(components = dp)
# 
# gr <- "PNI"
# 
# gr <- jmvcore::composeTerm(components = gr)



```


# Introduction to tableone


```{r, message = FALSE, tidy = FALSE, echo = F}
## Create a header using devtools::use_vignette("my-vignette")
## knitr configuration: http://yihui.name/knitr/options#chunk_options
library(knitr)
showMessage <- FALSE
showWarning <- TRUE
set_alias(w = "fig.width", h = "fig.height", res = "results")
opts_chunk$set(comment = "", error= TRUE, warning = showWarning, message = showMessage,
               tidy = FALSE, cache = F, echo = T,
               fig.width = 7, fig.height = 7, dev.args = list(family = "sans"))

## R configuration
options(width = 116, scipen = 5)
```

## What is tableone?

The tableone package is an R package that eases the construction of "Table 1", *i.e.*, patient baseline characteristics table commonly found in biomedical research papers. The packages can summarize both continuous and categorical variables mixed within one table. Categorical variables can be summarized as counts and/or percentages. Continuous variables can be summarized in the "normal" way (means and standard deviations) or "nonnormal" way (medians and interquartile ranges).


## Load packages

```{r}
## tableone package itself
library(tableone)
## survival pcakge for Mayo Clinic's PBC data
library(survival)
data(pbc)
```

## Single group summary

### Simplest use case

The simplest use case is summarizing the whole dataset. You can just feed in the data frame to the main workhorse function CreateTableOne(). You can see there are 418 patients in the dataset.
```{r}
CreateTableOne(data = pbc)
```

### Categorical variable conversion

Most of the categorical variables are coded numerically, so we either have to transform them to factors in the dataset or use factorVars argument to transform them on-the-fly. Also it's a better practice to specify which variables to summarize by the vars argument, and exclude the ID variable(s). How do we know which ones are numerically-coded categorical variables? Please check your data dictionary (in this case help(pbc)). This time I am saving the result object in a variable.

```{r}
## Get variables names
dput(names(pbc))
## Vector of variables to summarize
myVars <- c("time", "status", "trt", "age", "sex", "ascites", "hepato",
          "spiders", "edema", "bili", "chol", "albumin", "copper", "alk.phos",
          "ast", "trig", "platelet", "protime", "stage")
## Vector of categorical variables that need transformation
catVars <- c("status", "trt", "ascites", "hepato",
             "spiders", "edema", "stage")
## Create a TableOne object
tab2 <- CreateTableOne(vars = myVars, data = pbc, factorVars = catVars)
```

OK. It's more interpretable now. Binary categorical variables are summarized as counts and percentages of the second level. For example, if it is coded as 0 and 1, the "1" level is summarized. For 3+ category variable all levels are summarized. Please bear in mind, the percentages are calculated after excluding missing values.

```{r}
tab2
```

### Showing all levels for categorical variables

If you want to show all levels, you can use showAllLevels argument to the print() method.

```{r}
print(tab2, showAllLevels = TRUE)
```

### Detailed information including missingness

If you need more detailed information including the number/proportion missing. Use the summary() method on the result object. The continuous variables are shown first, and the categorical variables are shown second.

```{r}
summary(tab2)
```

### Summarizing nonnormal variables

It looks like most of the continuous variables are highly skewed except time, age, albumin, and platelet (biomarkers are usually distributed with strong positive skews). Summarizing them as such may please your future peer reviewer(s). Let's do it with the nonnormal argument to the print() method. Can you see the difference. If you just say nonnormal = TRUE, all variables are summarized the "nonnormal" way.

```{r}
biomarkers <- c("bili","chol","copper","alk.phos","ast","trig","protime")
print(tab2, nonnormal = biomarkers)
```

### Fine tuning

If you want to fine tune the table further, please check out ?print.TableOne for the full list of options.


## Multiple group summary

Often you want to group patients and summarize group by group. It's also pretty simple. Grouping by exposure categories is probably the most common way, so let's do it by the treatment variable. According to ?pbc, it is coded as (1) D-penicillmain (it's really "D-penicillamine"), (2) placebo, and (NA) not randomized. NA's do not function as a grouping variable, so it is dropped. If you do want to show the result for the NA group, then you need to recoded it something other than NA.

```{r}
tab3 <- CreateTableOne(vars = myVars, strata = "trt" , data = pbc, factorVars = catVars)
tab3
```

### Testing

As you can see in the previous table, when there are two or more groups group comparison p-values are printed along with the table (well, let's not argue the appropriateness of hypothesis testing for table 1 in an RCT for now.). Very small p-values are shown with the less than sign. The hypothesis test functions used by default are chisq.test() for categorical variables (with continuity correction) and oneway.test() for continous variables (with equal variance assumption, i.e., regular ANOVA). Two-group ANOVA is equivalent of t-test.

You may be worried about the nonnormal variables and small cell counts in the stage variable. In such a situation, you can use the nonnormal argument like before as well as the exact (test) argument in the print() method. Now kruskal.test() is used for the nonnormal continous variables and fisher.test() is used for categorical variables specified in the exact argument. kruskal.test() is equivalent to wilcox.test() in the two-group case. The column named test is to indicate which p-values were calculated using the non-default tests.

To also show standardized mean differences, use the smd option.

```{r}
print(tab3, nonnormal = biomarkers, exact = "stage", smd = TRUE)
```

## Exporting

My typical next step is to export the table to Excel for editing, and then to Word (clinical medical journals usually do not offer LaTeX submission).


### Quick and dirty way

The quick and dirty way that I usually use is copy and paste. Use the quote = TRUE argument to show the quotes and noSpaces = TRUE to remove spaces used to align text in the R console (the latter is optional). Now you can just copy and paste the whole thing to an Excel spread sheet. After pasting, click the small pasting icon to choose Use Text Import Wizard..., in the dialogue you can just click finish to fit the values in the appropriate cells. Then you can edit or re-align things as you like. I usualy center-align the group summaries, and right-aligh the p-values.

```{r}
print(tab3, nonnormal = biomarkers, exact = "stage", quote = TRUE, noSpaces = TRUE)
```

### Real export way

If you do not like the manual labor of copy-and-paste, you can potentially automate the task by the following way. The print() method for a TableOne object invisibly return a matrix identical to what you see. You can capture this by assignment to a variable (here tab3Mat). Do not use the quote argument in this case, the noSpaces argument is again optional. The self-contradictory printToggle = FALSE for the print() method avoids unnecessary printing if you wish. Then you can save the object to a CSV file. As it is a regular matrix object, you can save it to an Excel file using packages such as XLConnect.

```{r, eval = FALSE}
tab3Mat <- print(tab3, nonnormal = biomarkers, exact = "stage", quote = FALSE, noSpaces = TRUE, printToggle = FALSE)
## Save to a CSV file
write.csv(tab3Mat, file = "myTable.csv")
```

## Miscellaneous

### Categorical or continous variables-only

You may want to see the categorical or continous variables only. You can do this by accessing the CatTable part and ContTable part of the TableOne object as follows. summary() methods are defined for both as well as print() method with various arguments. Please see ?print.CatTable and ?print.ContTable for details.

```{r}
## Categorical part only
tab3$CatTable
## Continous part only
print(tab3$ContTable, nonnormal = biomarkers)
```

--------------------
- Authored by Kazuki Yoshida
- CRAN page: https://cran.r-project.org/package=tableone
- github page: https://github.com/kaz-yos/tableone



# Using standardized mean differences


```{r, message = FALSE, tidy = FALSE, echo = F}
## Create a header using devtools::use_vignette("my-vignette")
## knitr configuration: http://yihui.name/knitr/options#chunk_options
library(knitr)
showMessage <- FALSE
showWarning <- FALSE
set_alias(w = "fig.width", h = "fig.height", res = "results")
opts_chunk$set(comment = "", error= TRUE, warning = showWarning, message = showMessage,
               tidy = FALSE, cache = F, echo = T,
               fig.width = 10, fig.height = 10, dev.args = list(family = "sans"))

## R configuration
options(width = 130, scipen = 5)
```

## Standardized mean difference

The standardized (mean) difference is a measure of distance between two group means in terms of one or more variables. In practice it is often used as a balance measure of individual covariates before and after propensity score matching. As it is standardized, comparison across variables on different scales is possible. For definitions see http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3144483/#s11title .


Standardized mean differences can be easily calculated with tableone. All standardized mean differences in this package are absolute values, thus, there is no directionality.


## Load packages

```{r}

## tableone package itself
library(tableone)
## PS matching
library(Matching)
## Weighted analysis
library(survey)
## Reorganizing data
library(reshape2)
## plotting
library(ggplot2)

```


## Load data

The right heart catheterization dataset is available at http://biostat.mc.vanderbilt.edu/wiki/Main/DataSets . This dataset was originally used in Connors *et al*. JAMA 1996;276:889-897, and has been made publicly available.

```{r}

## Right heart cath dataset
rhc <- read.csv("http://biostat.mc.vanderbilt.edu/wiki/pub/Main/DataSets/rhc.csv")

```


## Unmatched table

Out of the 50 covariates, 32 have standardized mean differences of greater than 0.1, which is often considered the sign of important covariate imbalance (http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3144483/#s11title ).

```{r}

## Covariates
vars <- c("age","sex","race","edu","income","ninsclas","cat1","das2d3pc","dnr1",
          "ca","surv2md1","aps1","scoma1","wtkilo1","temp1","meanbp1","resp1",
          "hrt1","pafi1","paco21","ph1","wblc1","hema1","sod1","pot1","crea1",
          "bili1","alb1","resp","card","neuro","gastr","renal","meta","hema",
          "seps","trauma","ortho","cardiohx","chfhx","dementhx","psychhx",
          "chrpulhx","renalhx","liverhx","gibledhx","malighx","immunhx",
          "transhx","amihx")

## Construct a table
tabUnmatched <- CreateTableOne(vars = vars, strata = "swang1", data = rhc, test = FALSE)
## Show table with SMD
print(tabUnmatched, smd = TRUE)
## Count covariates with important imbalance
addmargins(table(ExtractSmd(tabUnmatched) > 0.1))

```


## Propensity score estimation

Usually a logistic regression model is used to estimate individual propensity scores. The model here is taken from "How To Use Propensity Score Analysis" (http://www.mc.vanderbilt.edu/crc/workshop_files/2008-04-11.pdf ). Predicted probabilities of being assigned to right heart catherterization, being assigned no right heart catherterization, being assigned to the true assignment, as well as the smaller of the probabilities of being assigned to right heart catherterization or no right heart catherterization are calculated for later use in propensity score matching and weighting.

```{r}

## Fit model
psModel <- glm(formula = swang1 ~ age + sex + race + edu + income + ninsclas +
                         cat1 + das2d3pc + dnr1 + ca + surv2md1 + aps1 + scoma1 +
                         wtkilo1 + temp1 + meanbp1 + resp1 + hrt1 + pafi1 +
                         paco21 + ph1 + wblc1 + hema1 + sod1 + pot1 + crea1 +
                         bili1 + alb1 + resp + card + neuro + gastr + renal +
                         meta + hema + seps + trauma + ortho + cardiohx + chfhx +
                         dementhx + psychhx + chrpulhx + renalhx + liverhx + gibledhx +
                         malighx + immunhx + transhx + amihx,
               family  = binomial(link = "logit"),
               data    = rhc)

## Predicted probability of being assigned to RHC
rhc$pRhc <- predict(psModel, type = "response")
## Predicted probability of being assigned to no RHC
rhc$pNoRhc <- 1 - rhc$pRhc

## Predicted probability of being assigned to the
## treatment actually assigned (either RHC or no RHC)
rhc$pAssign <- NA
rhc$pAssign[rhc$swang1 == "RHC"]    <- rhc$pRhc[rhc$swang1   == "RHC"]
rhc$pAssign[rhc$swang1 == "No RHC"] <- rhc$pNoRhc[rhc$swang1 == "No RHC"]
## Smaller of pRhc vs pNoRhc for matching weight
rhc$pMin <- pmin(rhc$pRhc, rhc$pNoRhc)

```


## Propensity score matching

The Matching package can be used for propensity score matching. The logit of propensity score is often used as the matching scale, and the matchign caliper is often 0.2 $\times$ SD(logit(PS)). See http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3144483/#s5title for suggestions. After matching, all the standardized mean differences are below 0.1.

```{r}

listMatch <- Match(Tr       = (rhc$swang1 == "RHC"),      # Need to be in 0,1
                   ## logit of PS,i.e., log(PS/(1-PS)) as matching scale
                   X        = log(rhc$pRhc / rhc$pNoRhc),
                   ## 1:1 matching
                   M        = 1,
                   ## caliper = 0.2 * SD(logit(PS))
                   caliper  = 0.2,
                   replace  = FALSE,
                   ties     = TRUE,
                   version  = "fast")
## Extract matched data
rhcMatched <- rhc[unlist(listMatch[c("index.treated","index.control")]), ]

## Construct a table
tabMatched <- CreateTableOne(vars = vars, strata = "swang1", data = rhcMatched, test = FALSE)
## Show table with SMD
print(tabMatched, smd = TRUE)
## Count covariates with important imbalance
addmargins(table(ExtractSmd(tabMatched) > 0.1))

```


## Propensity score matching weight

The matching weight method is a weighting analogue to the 1:1 pairwise algorithmic matching (http://www.ncbi.nlm.nih.gov/pubmed/23902694 ). The matching weight is defined as the smaller of the predicted probabilities of receiving or not receiving the treatment over the predicted probability of being assigned to the arm the patient is actually in. After weighting, all the standardized mean differences are below 0.1. The standardized mean differences in weighted data are explained in http://onlinelibrary.wiley.com/doi/10.1002/sim.6607/full .

```{r}

## Matching weight
rhc$mw <- rhc$pMin / rhc$pAssign
## Weighted data
rhcSvy <- svydesign(ids = ~ 1, data = rhc, weights = ~ mw)

## Construct a table (This is a bit slow.)
tabWeighted <- svyCreateTableOne(vars = vars, strata = "swang1", data = rhcSvy, test = FALSE)
## Show table with SMD
print(tabWeighted, smd = TRUE)
## Count covariates with important imbalance
addmargins(table(ExtractSmd(tabWeighted) > 0.1))

```


## Assessing balance before and after matching/weighting

A plot showing covariate balance is often constructed to demonstrate the balancing effect of matching and/or weighting. Given the same propensity score model, the matching weight method often achieves better covariate balance than matching.

```{r}

## Construct a data frame containing variable name and SMD from all methods
dataPlot <- data.frame(variable  = names(ExtractSmd(tabUnmatched)),
                       Unmatched = ExtractSmd(tabUnmatched),
                       Matched   = ExtractSmd(tabMatched),
                       Weighted  = ExtractSmd(tabWeighted))

## Create long-format data for ggplot2
dataPlotMelt <- melt(data          = dataPlot,
                     id.vars       = c("variable"),
                     variable.name = "Method",
                     value.name    = "SMD")

## Order variable names by magnitude of SMD
varNames <- as.character(dataPlot$variable)[order(dataPlot$Unmatched)]

## Order factor levels in the same order
dataPlotMelt$variable <- factor(dataPlotMelt$variable,
                                levels = varNames)

## Plot using ggplot2
ggplot(data = dataPlotMelt, mapping = aes(x = variable, y = SMD,
                                          group = Method, color = Method)) +
geom_line() +
geom_point() +
geom_hline(yintercept = 0.1, color = "black", size = 0.1) +
coord_flip() +
theme_bw() + theme(legend.key = element_blank())

```

To construct a side-by-side table, data can be extracted as a matrix and combined using the print() method, which actually invisibly returns a matrix.

```{r}

## Column bind tables
resCombo <- cbind(print(tabUnmatched, printToggle = FALSE),
                  print(tabMatched,   printToggle = FALSE),
                  print(tabWeighted,  printToggle = FALSE))

## Add group name row, and rewrite column names
resCombo <- rbind(Group = rep(c("No RHC","RHC"), 3), resCombo)
colnames(resCombo) <- c("Unmatched","","Matched","","Weighted","")
print(resCombo, quote = FALSE)

```


## Outcome analysis

The final analysis can be conducted using matched and weighted data. The results from the matching and matching weight are similar. ShowRegTable() function may come in handly.


```{r}

## Unmatched model (unadjsuted)
glmUnmatched <- glm(formula = (death == "Yes") ~ swang1,
                    family  = binomial(link = "logit"),
                    data    = rhc)
## Matched model
glmMatched <- glm(formula = (death == "Yes") ~ swang1,
                  family  = binomial(link = "logit"),
                  data    = rhcMatched)
## Weighted model
glmWeighted <- svyglm(formula = (death == "Yes") ~ swang1,
                      family  = binomial(link = "logit"),
                      design    = rhcSvy)

## Show results together
resTogether <- list(Unmatched = ShowRegTable(glmUnmatched, printToggle = FALSE),
                    Matched   = ShowRegTable(glmMatched, printToggle = FALSE),
                    Weighted  = ShowRegTable(glmWeighted, printToggle = FALSE))
print(resTogether, quote = FALSE)

```

--------------------
- Authored by Kazuki Yoshida
- CRAN page: https://cran.r-project.org/package=tableone
- github page: https://github.com/kaz-yos/tableone



```{r}
doi_list <- c(
    "10.4103/IJPM.IJPM_85_17",
    "10.5146/tjpath.2017.01404",
    "10.1038/modpathol.2017.106",
    "10.1038/modpathol.2017.60",
    "10.1097/PAS.0000000000000863",
    "10.1097/PHM.0000000000000727",
    "10.1038/modpathol.2016.223",
    "10.1097/PAS.0000000000000782",
    "10.1007/s00428-016-2014-x",
    "10.1038/modpathol.2016.125",
    "10.1111/cup.12790",
    "10.1038/modpathol.2016.174",
    "10.1016/j.ijscr.2016.04.003",
    "10.1038/modpathol.2016.124",
    "10.1038/modpathol.2016.105",
    "10.1016/j.anndiagpath.2016.04.002",
    "10.1097/PAI.0000000000000353",
    "10.1016/j.jmoldx.2015.11.006",
    "10.1245/s10434-015-4861-0",
    "10.1097/MEG.0000000000000463",
    "10.4103/0970-9371.160549",
    "10.1038/modpathol.2015.61",
    "10.1245/s10434-015-4499-y",
    "10.1097/PAS.0000000000000408",
    "10.1016/j.ijrobp.2014.11.004",
    "10.1053/j.semdp.2014.08.009",
    "10.1038/modpathol.2014.156",
    "10.18632/oncotarget.1682",
    "10.1371/journal.pone.0088525",
    "10.1097/PAS.0000000000000165",
    "10.1309/AJCP0FKDP7ENVKEV",
    "10.1007/s12022-013-9295-2",
    "10.1007/s11102-013-0551-8",
    "10.1007/s12022-013-9275-6",
    "10.1016/j.ajg.2013.08.008",
    "10.1631/jzus.B1300016",
    "10.1111/cyt.12093",
    "10.2214/AJR.12.9139",
    "10.3109/0886022X.2012.745115",
    "10.1111/cyt.12021",
    "10.1053/j.semdp.2012.08.010",
    "10.1097/PAS.0b013e31826399d8",
    "10.5146/tjpath.2012.01125",
    "10.1016/j.urolonc.2012.06.014",
    "10.1097/COC.0b013e3182467efa",
    "10.1038/modpathol.2012.37",
    "10.1007/s00701-011-1241-9",
    "10.3171/2011.5.SPINE10303",
    "10.1007/s00296-011-1866-2",
    "10.1097/MPA.0b013e318201c935",
    "10.1016/j.jaapos.2010.01.013",
    "10.1007/s00701-010-0677-7",
    "10.1097/PGP.0b013e3181b70176",
    "10.1155/2018/1072403",
    "10.1155/2013/157456",
    "10.1155/2019/4301528",
    "10.1155/2014/943162",
    "10.1155/2017/4583434",
    "10.3892/mmr.2017.6299",
    "10.1002/job.1787",
    "10.1111/j.1365-2044.2012.07128.x"
)

retracted_list <-
                retractcheck::retractcheck(
                    dois = doi_list,
                    database = "rw",
                    return = "all"
                )


(table_retracted_list <- kableExtra::kable(
                retracted_list,
                format = "html"
                )
)

```

```{r}
            info_list <-
            RefManageR::GetBibEntryWithDOI(doi = doi_list)


            table_info_list <- kableExtra::kable(
                info_list,
                format = "html"
            )
```

```{r}

ids <- rcrossref::id_converter(x = doi_list)

ids[["records"]]

```


# kappaSize

> kappaSize::Power3Cats(kappa0=0.3, kappa1=0.6, props=c(0.40, 0.30, 0.30), alpha=0.05, power=0.80)
A minimum of 50 subjects are required for this study of interobserver agreement. 

https://journals.lww.com/ajsp/Abstract/9000/Reproducibility_of_AJCC_Criteria_for_Classifying.97399.aspx


https://cran.r-project.org/web/packages/kappaSize/kappaSize.pdf



# Age Pyramid

```{r age pyramid}

mydata2 <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

mydata2[["Age"]] <- jmvcore::toNumeric(mydata2[["Age"]])

mydata2[["Gender"]] <- as.factor(mydata2[["Sex"]])

            mydata2 <- mydata2 %>%
                dplyr::mutate(
                    Gender2 = dplyr::case_when(
                        Gender == "Female" ~ "Female",
                        TRUE ~ "Male"
                        ))


            mydata2[["Pop"]] <- cut(mydata2[["Age"]],
                                 include.lowest = TRUE,
                                 right = TRUE,
                                 breaks = c(
                                     seq(from = 0,
                                         to = max(mydata2[["Age"]], na.rm = TRUE),
                                         by = 5
                                     ),
                                     max(mydata2[["Age"]], na.rm = TRUE)
                                 ),
                                 ordered_result = TRUE
            )


            plotData <- mydata2 %>%
                dplyr::select(Gender = Gender2,
                              Pop
                              ) %>%
                dplyr::group_by(Gender, Pop) %>%
                dplyr::count()


            plotData2 <- plotData %>%
                tidyr::pivot_wider(data = .,
                                   names_from = Gender,
                                   values_from = n) %>%
                dplyr::arrange(dplyr::desc(Pop))



plotData3 <- 
    as.data.frame(plotData2) %>%
    tibble::rownames_to_column(.data = .) %>% 
    dplyr::filter(!is.na(Pop)) %>% 
    dplyr::mutate(
        Pop = as.character(Pop)
    )




```




```{r}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

source("https://raw.githubusercontent.com/achekroud/nomogrammer/master/nomogrammer.r")

nomogrammer(Prevalence = 0.6, Sens = 0.7, Spec = 0.8)


```



```{r}
library(dplyr)
library(riskmetric)

# pkg_ref(c("riskmetric", "utils", "tools")) %>%
pkg_ref(x = "ClinicoPath") %>% 
  as_tibble() %>%
  pkg_assess() %>%
  pkg_score() %>%
  mutate(risk = summarize_scores(.))
```



# Benford Analysis

https://www.iamnagdev.com/?p=926

```{r}
# load libraries
library(gtrendsR)
library(reshape2)
library(dplyr)
library(benford.analysis)

# read data
data = read.csv("https://www2.census.gov/programs-surveys/popest/datasets/2010-2019/counties/totals/co-est2019-alldata.csv", header = T)

# filter out columns
data_filt = data %>%
    filter(COUNTY != 0) %>%
    select(c(STNAME, CTYNAME, CENSUS2010POP))

# perform benford analysis
trends = benford(data_filt$CENSUS2010POP,
                 number.of.digits = 1,
                 discrete = T,
                 sign = "positive") 
trends

# plot results
plot(trends)
```


# Benford Analysis for Images



```{r}
# install.packages("imagerExtra")
# load libraries
library(imagerExtra)
library(imager)
library(benford.analysis)
library(imagerExtra)
library(dplyr)

# load image
im = load.image("/Users/serdarbalciold/histopathRprojects/ClinicoPath/tododata/save1-2048x1152.jpg") %>% grayscale()

# perform (DCT)
im_df = DCT2D(im) %>% as.data.frame()

# apply benford law
bfd.im = benford(im_df$value, number.of.digits = 1, discrete = T, round = 1, sign = "both") 
bfd.im

# plot the results
plot(bfd.im)

```




# pairchi2

```{r}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

row <- "LVI"
col <- "Grade"

row <- jmvcore::composeTerm(components = row)
col <- jmvcore::composeTerm(components = col)


data <- jmvcore::select(df = deneme,
                        columnNames = c(row, col))


conf_table <- table(data[[row]], data[[col]])
                                


chi2test <- try(chisq.test(conf_table, correct = FALSE))

rmngb::pairwise.chisq.test(x = conf_table)


x <- sample(1:2, 1e3, TRUE)
g <- sample(1:4, 1e3, TRUE)
pairwise.chisq.test(x, g)
tab <- table(g, x)
pairwise.fisher.test(conf_table, p.adj = "bonf")



M <- as.table(rbind(c(762, 327, 468), c(484, 239, 477)))
dimnames(M) <- list(gender = c("F", "M"),
                    party = c("Democrat","Independent", "Republican"))

# Pass data matrix to chisq.posthoc.test function
chisq.posthoc.test::chisq.posthoc.test(M)
```


```{r}
# # Continious Explanatory ----
                #
                #
                # if ( !is.null(self$options$contexpl) ) {
                #
                #
                #                     todo <- glue::glue("
                #                                        <br>
                #                                        Continious Explanatory
                #                                        <br>
                #                                        <hr>")
                #                     html <- self$results$todo
                #                     html$setContent(todo)
                #
                #
                #                     # Disable other tables
                #                     self$results$medianSummary$setVisible(FALSE)
                #                     self$results$medianTable$setVisible(FALSE)
                #                     self$results$survTableSummary$setVisible(FALSE)
                #                     self$results$survTable$setVisible(FALSE)
                #                     self$results$pairwiseSummary$setVisible(FALSE)
                #                     self$results$pairwiseTable$setVisible(FALSE)
                #
                #
                #
                #
                #
                #                     # Continious Cox Regression ----
                #
                #
                #                     formula2 <- as.vector(self$options$contexpl)
                #
                #                     sas <- self$options$sas
                #
                #                     if (sas) {
                #                         formula2 <- 1
                #                     }
                #
                #                     myformula <- paste("Surv(", "mytime", "," , "myoutcome", ")")
                #
                #                     finalfit::finalfit(.data = mydata,
                #                                        dependent = myformula,
                #                                        explanatory = formula2,
                #
                #                                        metrics = TRUE
                #                     ) -> tCox
                #
                #
                #                     tCoxtext2 <- glue::glue("
                #                 <br>
                #                 <b>Model Metrics:</b>
                #                   ",
                #                 unlist(
                #                     tCox[[2]]
                #                 ),
                #                 "
                #                 <br>
                #                 ")
                #
                #
                #                     self$results$tCoxtext2$setContent(tCoxtext2)
                #
                #
                #
                #
                #                     tCox_df <- tibble::as_tibble(tCox[[1]], .name_repair = "minimal") %>%
                #                         janitor::clean_names(dat = ., case = "snake")
                #
                #
                #                     # Continious Cox-Regression Table ----
                #
                #                     coxTable <- self$results$coxTable
                #
                #                     data_frame <- tCox_df
                #
                #                     names(data_frame) <- c(
                #                         "Explanatory",
                #                         "Levels",
                #                         "all",
                #                         "HR_univariable",
                #                         "HR_multivariable"
                #                     )
                #
                #                     for(i in seq_along(data_frame[,1,drop=T])) {
                #                         coxTable$addRow(rowKey = i, values = c(data_frame[i,]))
                #                     }
                #
                #
                #                     # Continious coxTable explanation ----
                #
                #
                #                     tCox_df <- tibble::as_tibble(tCox[[1]], .name_repair = "minimal") %>%
                #                         janitor::clean_names(dat = ., case = "snake")
                #
                #                     names(tCox_df) <- names(data_frame) <- c(
                #                         "Explanatory",
                #                         "Levels",
                #                         "all",
                #                         "HR_univariable",
                #                         "HR_multivariable"
                #                     )
                #
                #
                #                     # https://stackoverflow.com/questions/38470355/r-fill-empty-cell-with-value-of-last-non-empty-cell
                #
                #                     while(length(ind <- which(tCox_df$Explanatory == "")) > 0){
                #                         tCox_df$Explanatory[ind] <- tCox_df$Explanatory[ind - 1]
                #                     }
                #
                #                     # https://stackoverflow.com/questions/51180290/mutate-by-group-in-r
                #
                #                     tCox_df %>%
                #                         dplyr::group_by(Explanatory) %>%
                #                         dplyr::mutate(firstlevel = first(Levels)) %>%
                #                         dplyr::mutate(
                #                             coxdescription = glue::glue(
                #                                 "When {Explanatory} increases 1 unit, the hazard increases {HR_multivariable} times."
                #                             )
                #                         ) %>%
                #                         dplyr::filter(HR_univariable != '-') %>%
                #                         dplyr::pull(coxdescription) -> coxSummary
                #
                #
                #
                #                     coxSummary <- unlist(coxSummary)
                #                     self$results$coxSummary$setContent(coxSummary)
                #
                #
                #
                #
                #                 # Continuous Optimal Cut-off ----
                #
                #                 # https://rpkgs.datanovia.com/survminer/reference/surv_cutpoint.html
                #
                #                     findcut <- self$options$findcut
                #
                #                     if (findcut) {
                #
                #                     res.cut <- survminer::surv_cutpoint(
                #                         mydata,
                #                         time = "mytime",
                #                         event = "myoutcome",
                #                         self$options$contexpl,
                #                         minprop = 0.1,
                #                         progressbar = TRUE
                #                     )
                #
                #                     # res.cut$Age
                #                     # res.cut$data
                #                     # res.cut$minprop
                #                     # res.cut$cutpoint
                #
                #
                #                     # Cut-off Table ----
                #
                #                     rescut_summary <- summary(res.cut)
                #
                #                     # self$results$rescutTable$setContent(rescut_summary)
                #
                #
                #                     rescutTable <- self$results$rescutTable
                #
                #                     rescutTable$setTitle(paste0(self$options$contexpl))
                #
                #
                #                     data_frame <- rescut_summary
                #                     for (i in seq_along(data_frame[,1,drop = T])) {
                #                         rescutTable$addRow(rowKey = i, values = c(data_frame[i,]))
                #                     }
                #
                #
                #                     # categorisation ----
                #
                #                     res.cat <- survminer::surv_categorize(res.cut)
                #
                #
                #                     # View mydata ----
                #
                #                     # self$results$mydataview$setContent(head(res.cat, 20))
                #
                #                     # Prepare Data For Continuous Explanatory Plots ----
                #
                #                     plotData4 <- res.cut
                #
                #                     image4 <- self$results$plot4
                #                     image4$setState(plotData4)
                #
                #                     plotData5 <- res.cat
                #
                #                     image5 <- self$results$plot5
                #                     image5$setState(plotData5)
                #
                #
                #                     }
                #
                #
                #
                #
                #                     return()
                #
                #
                #
                #                 }

```


```{r}
# stopifnot(lubridate::is.Date(
                #     lubridate::ymd_hms(
                #         mydata[[fudate]]
                #         )
                #     )
                # )
                #
                # stopifnot(lubridate::is.Date(lubridate::ymd_hms((mydata[[dxdate]]))))

                # stopifnot(
                #     inherits(mydata[[dxdate]], c("POSIXct","POSIXt", "POSIXlt"))
                # )
                # stopifnot(
                #     inherits(mydata[[fudate]], c("POSIXct","POSIXt", "POSIXlt"))
                # )
                # 
                #
```


```{r}
# mydata[["interval"]] <- lubridate::interval(
                #     start = lubridate::ymd_hms(mydata[[dxdate]]),
                #     end = lubridate::ymd_hms(mydata[[fudate]])
                # )

                # mydata[["mytime"]] <- lubridate::time_length(mydata[["interval"]], timetypeoutput)
```


```{r}
# if ( !is.null(self$options$explanatory)
            #      # && !is.null(self$options$contexpl)
            #      ) {
            #
            #     stop("If you want to use continuous and categorical variables together as explanatory variables, please use Multivariate Survival Analysis function in jsurvival module.")
            #
            # }


```



```{r}
# ,
# .plot4 = function(image4, ggtheme, theme, ...) {  # <-- the plot4 function ----
#
#
#     findcut <- self$options$findcut
#
#     if (!findcut)
#         return()
#
#     # if (nrow(self$data) == 0)
#     #     stop('Data contains no (complete) rows')
#
#     if ( !is.null(self$options$explanatory) && !is.null(self$options$contexpl)) {
#
#         stop("If you want to use continuous and categorical variables together as explanatory variables, please use Multivariate Survival Analysis function in jsurvival module.")
#
#     }
#
#
#     # if (is.null(self$options$contexpl) || is.null(self$options$outcome) || is.null(self$options$elapsedtime) )
#     #     return()
#
#     plotData <- image4$state
#
#     res.cut <- plotData
#
#     plot4 <- plot(res.cut, self$options$contexpl, palette = "npg")
#
#
#     print(plot4)
#     TRUE
# }


# ,
# .plot5 = function(image5, ggtheme, theme, ...) {  # <-- the plot5 function ----
#
#
#     findcut <- self$options$findcut
#
#     if (!findcut)
#         return()
#
#     # if (nrow(self$data) == 0)
#     #     stop('Data contains no (complete) rows')
#
#     if ( !is.null(self$options$explanatory) && !is.null(self$options$contexpl)) {
#
#         stop("If you want to use continuous and categorical variables together as explanatory variables, please use Multivariate Survival Analysis function in jsurvival module.")
#
#     }
#
#
#     # if (is.null(self$options$contexpl) || is.null(self$options$outcome) || is.null(self$options$elapsedtime) )
#     #     return()
#
#     plotData <- image5$state
#
#     res.cat <- plotData
#
#
#     contfactor <- jmvcore::constructFormula(terms = self$options$contexpl)
#
#
#     sas <- self$options$sas
#
#     if (sas) {
#         contfactor <- 1
#     }
#
#
#
#     # contfactor <- as.formula(contfactor)
#
#     myformula <- paste0("survival::Surv(mytime, myoutcome) ~ ", contfactor)
#
#     myformula <- as.formula(myformula)
#
#     fit <- survminer::surv_fit(formula = myformula,
#                                data = res.cat
#                                )
#
#     plot5 <- survminer::ggsurvplot(fit,
#                                    data = res.cat,
#                                    risk.table = self$options$risktable,
#                                    conf.int = self$options$ci95)
#
#
#     print(plot5)
#     TRUE
# }

```



# MST

```{r MST}
deneme <- readxl::read_xlsx(path = "/Users/serdarbalciold/histopathRprojects/ClinicoPath/tododata/histopathology-template2019-11-25.xlsx")

deneme <- jmvcore::select(deneme,
                          c("OverallTime",
                            "Outcome",
                            "LVI",
                            "PNI",
                            "Age",
                            "ID")
                          )

deneme <- jmvcore::naOmit(deneme)

fit <- 
    MST::MST(
        formula = survival::Surv(OverallTime, Outcome) ~ LVI + PNI + Age | ID,
        data = deneme,
        method = "marginal",
        minsplit = 100,
        minevents = 20
        )

tree_final <- MST::getTree(fit, "4")

plot(tree_final)


deneme$term_nodes <- as.factor(predict(tree_final, newdata = deneme, type = "node"))

coxph(Surv(time, status) ~ term_nodes + cluster(id), data = data)



```



# bibliography


```{r}
doi_list <- c(
"10.1007/s00701-010-0677-7"
, "10.1097/PGP.0b013e3181b70176"
, "10.1155/2018/1072403"
, "10.1155/2013/157456"
, "10.1155/2019/4301528"
, "10.1155/2014/943162"
, "10.1155/2017/4583434"
, "10.3892/mmr.2017.6299"
)

ids <- rcrossref::id_converter(x = doi_list, type = "doi")

ids$records$pmid

ids[["records"]]

kableExtra::kable(
    ids,
    format = "html"
)

```


# jjstatsplot

```{r}
deneme <- readxl::read_xlsx(path = here::here("tododata", "histopathology-template2019-11-25.xlsx"))

deneme$Age <- jmvcore::toNumeric(deneme$Age)

deneme$LVI <- as.factor(deneme$LVI)

deneme <- jmvcore::naOmit(deneme)

ggstatsplot::ggwithinstats(
  data = deneme,
  x = LVI,
  y = Age
)

ggstatsplot::ggbetweenstats(
  data = deneme,
  x = LVI,
  y = Age
)


ggstatsplot::ggbarstats(
  data = deneme,
  x = LVI,
  y = PNI
)




```




# report


```{r}
#' # Data
report::report_statistics(iris$Sepal.Length)
report::report_statistics(as.character(round(iris$Sepal.Length, 1)))
report::report_statistics(iris$Species)
report::report_statistics(iris)
#'
#' # h-tests
report::report_statistics(t.test(iris$Sepal.Width, iris$Sepal.Length))
report::report_statistics(cor.test(iris$Sepal.Width, iris$Sepal.Length))
#'
#' # ANOVA
report::report_statistics(aov(Sepal.Length ~ Species, data=iris))
```




